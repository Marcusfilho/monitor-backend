const WebSocket = require("ws");

const __SB_PENDING = new Map();
function __sbExtractMtkn(obj){
  return (obj?.response?.properties?.mtkn ?? obj?.properties?.mtkn ?? obj?.response?.mtkn ?? obj?.mtkn ?? null);
}
function __sbResolve(mtkn, payload){
  const key = String(mtkn);
  const entry = __SB_PENDING.get(key);
  if (!entry) return;
  clearTimeout(entry.t);
  __SB_PENDING.delete(key);
  entry.resolve(payload);
}

function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

function genFlowId(){ return String(200000 + Math.floor(Math.random()*800000)); }
function genMtkn(){
  const now = Date.now().toString();
  let rnd = Math.floor(Math.random() * 1e12).toString();
  while (rnd.length < 12) rnd = "0" + rnd;
  return now + rnd;
}
function decodeMaybe(s){
  if (typeof s === "string" && (s.startsWith("%7B") || s.startsWith("%7b"))) {
    try { return decodeURIComponent(s); } catch {}
  }
  return s;
}

function buildFrame(actionName, params, sessionToken){
  const mtkn = genMtkn();
  return {
    mtkn,
    frame: {
      action: {
        flow_id: genFlowId(),
        name: actionName,
        parameters: { ...params, _action_name: actionName, mtkn: String(mtkn) },
        session_token: String(sessionToken || ""),
        mtkn: String(mtkn)
      }
    }
  };
}

function sendFrame(ws, actionName, params, sessionToken){
  const { mtkn, frame } = buildFrame(actionName, params, sessionToken);
  const rawJson = JSON.stringify(frame);

  // default RAW (igual Tampermonkey). Para mandar %7B..., use SB_SEND_ENCODE=1
  const out = process.env.SB_SEND_ENCODE === "1" ? encodeURIComponent(rawJson) : rawJson;

  console.log(`[sb] >> ${actionName} mtkn=${mtkn}`);
  ws.send(out);
  return mtkn;
}

function waitRowByMtkn(ws, mtkn, timeoutMs=15000){
  return new Promise((resolve, reject) => {
    const t = setTimeout(() => {
      ws.removeListener("message", onMsg);
      reject(new Error("Timeout esperando mtkn=" + mtkn));
    }, timeoutMs);

    function onMsg(data){
      const text = decodeMaybe(String(data));
      if (!text.includes(mtkn)) return;
      try {
        const obj = JSON.parse(text);
        // "row" costuma vir sem obj.response (igual no seu script ok)
        if (obj && (obj.process_id || !obj.response)) {
          clearTimeout(t);
          ws.removeListener("message", onMsg);
          resolve(obj);
        }
      } catch {}
    }
    ws.on("message", onMsg);
  });
}

(async () => {
  const url = process.env.MONITOR_WS_URL;
  const sessionToken = process.env.MONITOR_SESSION_TOKEN;

  if (!url) throw new Error("Faltou MONITOR_WS_URL");
  if (!sessionToken) throw new Error("Faltou MONITOR_SESSION_TOKEN");

  const cookie = process.env.MONITOR_WS_COOKIE || "";
  const origin = process.env.MONITOR_WS_ORIGIN || "https://operation.traffilog.com";

  const [clientId, clientName, vehicleId, vehicleSettingId, ...rest] = process.argv.slice(2);
  const comment = rest.join(" ") || "vm scheme builder";

  if (!clientId || !clientName || !vehicleId || !vehicleSettingId) {
    console.error("Uso: node tools/sb_run_vm.js <clientId> <clientName> <vehicleId> <vehicleSettingId> [comment...]");
    process.exit(2);
  }

  // IMPORTANTE: sem subprotocol (evita "invalid subprotocol")
  const ws = new WebSocket(url, {
    headers: cookie ? { Cookie: cookie } : {},
    origin,
    handshakeTimeout: 15000,
    perMessageDeflate: false,
  });

  ws.on("open", () => console.log("[sb] WS open"));
  ws.on("close", (c,r) => console.log("[sb] WS close", c, String(r||"")));
  ws.on("error", (e) => console.log("[sb] WS error", e && e.message ? e.message : e));

  ws.on("message", (data) => {
    const text = decodeMaybe(String(data));
    if (text.includes("action_value")) {
      try { console.log("[sb] << action_value msg:", JSON.parse(text)); } catch {}
    }
  });

  await new Promise((res, rej) => {
    ws.once("open", res);
    ws.once("error", rej);
  });

  // 0) INIT (igual quando a tela carrega): get_client_vehicles_opr
  sendFrame(ws, "get_client_vehicles_opr", {
    vcls_from_previous_process: "0",
    is_checked: "0",
    last_ignition_status: "0",
    license_nmbr: "",
    inner_id: "",
    vehicle_id: "",
    vin_nmbr: "",
    client_group: "",
    vehicle_type_descr: "",
    is_last_SB_error: "0",
    LAST_SB_STATUS_ID: "",
    current_firmware: "",
    is_assigned_fw: "0",
    time_interval_id: "",
    assigned_firmware: "",
    loaded_setting_name: "",
    is_assigned_setting: "0",
    assigned_setting_name: "",
    processor_type: "",
    hardware_type: "",
    client_id: String(clientId),
    client_name: String(clientName)
  }, sessionToken);
  await sleep(800);

  // 1) Marca veículo
  sendFrame(ws, "vcls_check_opr", {
    client_id: String(clientId),
    vehicle_id: String(vehicleId),
    client_name: String(clientName),
    is_checked: "1"
  }, sessionToken);
  await sleep(300);

  // 2) associate call 0
  sendFrame(ws, "associate_vehicles_actions_opr", {
    tag: "loading_screen",
    client_id: String(clientId),
    client_name: String(clientName),
    action_source: "0",
    action_id: "1",
    call_num: "0"
  }, sessionToken);
  await sleep(300);

  // 3) associate call 1 (setting)
  sendFrame(ws, "associate_vehicles_actions_opr", {
    client_id: String(clientId),
    client_name: String(clientName),
    vehicle_setting_id: String(vehicleSettingId),
    action_source: "0",
    action_id: "1",
    call_num: "1"
  }, sessionToken);
  await sleep(500);

  // 4) review
  sendFrame(ws, "review_process_attributes", { client_id: String(clientId) }, sessionToken);
  await sleep(200);

  // 5) get review -> process_id
  const mtknReview = sendFrame(ws, "get_vcls_action_review_opr", {
    client_id: String(clientId),
    client_name: String(clientName),
    action_source: "0"
  }, sessionToken);

  const reviewRow = await waitRowByMtkn(ws, mtknReview, 15000);
  const processId = String(reviewRow && reviewRow.process_id ? reviewRow.process_id : "");
  if (!processId) {
    console.log("[sb] reviewRow:", reviewRow);
    throw new Error("Não veio process_id");
  }
  console.log("[sb] process_id =", processId);

  // 6) execute
  sendFrame(ws, "execute_action_opr", {
    tag: "loading_screen",
    client_id: String(clientId),
    action_source: "0",
    process_id: processId,
    comment: String(comment),
    toggle_check: "1"
  }, sessionToken);

  console.log("[sb] execute_action_opr enviado.");
  await sleep(2000);
  ws.close(1000, "done");
})();

// PATCH_WAITFORMTKN_V2
function waitForMtkn(mtkn, timeoutMs = 25000) {
  const key = String(mtkn);
  return new Promise((resolve, reject) => {
    const t = setTimeout(() => {
      __SB_PENDING.delete(key);
      reject(new Error("Timeout esperando mtkn=" + key));
    }, timeoutMs);
    __SB_PENDING.set(key, { resolve, reject, t });
  });
}
