
<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>CAN Probe — Vehicle Monitor snapshot</title>
  <style>
    :root{
      --bg:#0b0f12; --panel:#0f1620; --muted:#93a4b8; --text:#e8eef2; --line:#1f2a38;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--text);font-family:var(--sans)}
    header{padding:16px 18px;border-bottom:1px solid var(--line);display:flex;gap:12px;align-items:center;justify-content:space-between}
    header h1{margin:0;font-size:16px;font-weight:700}
    header .nav{display:flex;gap:10px;align-items:center;font-size:12px}
    header a{color:#cfe6ff;text-decoration:none;border:1px solid var(--line);padding:6px 10px;border-radius:10px;background:#0b1118}
    .wrap{padding:16px 18px}
    .grid{display:grid;grid-template-columns: 420px 1fr; gap:14px; align-items:start}
    .card{background:var(--panel);border:1px solid var(--line);border-radius:14px;padding:14px}
    .card h2{margin:0 0 10px 0;font-size:13px;color:#cfe6ff}
    label{display:block;font-size:12px;color:var(--muted);margin:10px 0 6px}
    input, textarea{
      width:100%;padding:10px 12px;border-radius:12px;border:1px solid #273245;background:#0b1118;color:var(--text);outline:none;
      font-family:var(--sans);font-size:13px
    }
    textarea{min-height:70px;resize:vertical}
    button{
      cursor:pointer;border:1px solid #2a3a52;background:#122033;color:#e8eef2;border-radius:12px;padding:10px 12px;font-weight:650;
    }
    button:hover{border-color:#3b5478}
    button.secondary{background:#0b1118}
    .btnrow{display:flex;gap:10px;flex-wrap:wrap}
    .hint{font-size:12px;color:var(--muted);line-height:1.4;margin-top:10px}
    .status{font-family:var(--mono);font-size:12px;color:var(--muted);margin-top:10px}
    pre{
      margin:0; padding:12px; border-radius:14px; border:1px solid #273245;
      background:#000; color:#e8eef2; font-family:var(--mono); font-size:12px; line-height:1.35;
      overflow:auto; max-height: 74vh;
    }
  
    /* === CAN Snapshot UI (raw_value) === */
    .kv{font-size:12px;color:var(--muted);margin:8px 0 10px;display:flex;gap:10px;flex-wrap:wrap}
    .pill{border:1px solid #273245;background:#0b1118;padding:4px 8px;border-radius:999px}
    .tableWrap{border:1px solid #273245;border-radius:14px;overflow:auto;max-height:32vh;background:#000}
    table{width:100%;border-collapse:collapse;font-family:var(--mono);font-size:12px}
    th,td{padding:7px 10px;border-bottom:1px solid #1f2a38;vertical-align:top}
    th{position:sticky;top:0;background:#0b1118;color:#cfe6ff}
    tr:hover td{background:#0b1118}
    details summary{cursor:pointer;color:#cfe6ff;font-size:12px;margin:10px 0}
  

    /* === Probe screen (validação CAN) === */
    .probeScreen{
      background:#000;border:1px solid #273245;border-radius:20px;padding:10px; margin:8px 0 12px;
      font-family:var(--mono); color:#f4f7fb;
    }
    .probeRow{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:8px}
    .probeBox{
      border:1px solid #25b5ff; border-radius:10px; padding:6px 8px; min-height:42px;
      display:flex; align-items:center; justify-content:center; text-align:center;
      background:#02070b;
      font-size:11px; line-height:1.25;
    }
    .probeBox b{color:#fff; font-weight:700}
    .probeBig{
      border:1px solid #25b5ff; border-radius:26px; padding:14px 16px; background:#02070b;
      min-height:260px;
    }
    .probeSectionTitle{color:#fff;font-weight:700;margin:8px 0 4px 0;font-size:12px}
    .probeItem{margin:2px 0; color:#dfeaf7; font-size:11px}
    .probeItem .k{display:inline-block; min-width:132px; color:#dfeaf7}
    .probeItem .v{color:#fff; font-style:italic}
    .probeItem.miss .v{color:#9aaabd}
    .probeLegend{font-size:11px;color:#93a4b8;margin:8px 0 0}
    .okDot,.badDot,.unkDot{
      display:inline-block; width:8px; height:8px; border-radius:999px; margin-right:6px; vertical-align:middle;
    }
    .okDot{background:#36d66b}
    .badDot{background:#ff6161}
    .unkDot{background:#93a4b8}

</style>
</head>
<body>
<header>
  <h1>CAN Probe <span style="opacity:.8;font-size:12px">— cria instalação CAN_PROBE e puxa snapshot</span></h1>
  <div class="nav">
    <a href="/app/app_installations_v2.html">Voltar (v2)</a>
    <a href="/app/app_installations_v1.html">v1</a>
  </div>
</header>

<div class="wrap">
  <div class="grid">
    <div class="card">
      <h2>1) Criar “instalação probe” (sem HTML5/SB)</h2>

      <label>vehicle_id (real, online)</label>
      <input id="vehicle_id" placeholder="ex.: 1940478" />

      <label>target_client_id (opcional)</label>
      <input id="target_client_id" placeholder="ex.: 218572" />

      <label>vehicleSettingId (opcional)</label>
      <input id="vehicleSettingId" placeholder="ex.: 5592" />

      <label>comments (opcional)</label>
      <textarea id="comments" placeholder="ex.: CAN PROBE..."></textarea>

      <div class="btnrow" style="margin-top:12px">
        <button id="btnCreate">Criar CAN_PROBE</button>
        <button class="secondary" id="btnReq">Request snapshot</button>
        <button class="secondary" id="btnLoad">Carregar</button>
        <button class="secondary" id="btnApprove">Aprovar CAN</button>
      </div>

      <hr style="border:none;border-top:1px solid var(--line);margin:14px 0" />

      <h2>2) Ou inspecionar um installation_id existente</h2>
      <label>installation_id</label>
      <input id="installation_id" placeholder="inst_..." />

      <div class="hint">
        <div>• Esse probe depende do backend aceitar <b>service=CAN_PROBE</b> sem enfileirar job HTML5.</div>
        <div>• Depois você usa <b>Request snapshot</b> e vai recarregando até aparecer CAN.</div>
      </div>

      <div class="status" id="status">status: pronto</div>
    </div>

    <div class="card">
      <h2>CAN Probe (validação)</h2>
      <div class="kv" id="canSummary">
        <span class="pill">snapshot: —</span>
        <span class="pill" id="pillParams">params: 0</span>
        <span class="pill" id="pillParamsWith">com valor: 0</span>
        <span class="pill" id="pillMs">module: 0</span>
      </div>

      <div id="probeScreen" class="probeScreen">aguardando snapshot...</div>

      <details>
        <summary>Debug / Parameters / Module State</summary>

        <label style="margin-top:8px">Filtro (Parameters)</label>
        <input id="canFilter" placeholder="filtrar por name / id / type..." />

        <div class="muted" style="font-size:12px;color:var(--muted);margin:10px 0 6px">Parameters</div>
        <div class="tableWrap">
          <table>
            <thead>
              <tr><th>name</th><th>type</th><th>value (value/raw_value)</th><th>last_update</th><th>source</th></tr>
            </thead>
            <tbody id="tblParamsBody"></tbody>
          </table>
        </div>

        <div class="muted" style="font-size:12px;color:var(--muted);margin:12px 0 6px">Module State</div>
        <div class="tableWrap">
          <table>
            <thead>
              <tr><th>id</th><th>name</th><th>active</th><th>ok</th><th>was_ok</th><th>message</th></tr>
            </thead>
            <tbody id="tblMsBody"></tbody>
          </table>
        </div>

        <details>
          <summary>JSON (inst + snapshot)</summary>
          <pre id="out">{}</pre>
        </details>
      </details>
    </div>
  </div>
</div>

<script>
  const qs = (id) => document.getElementById(id);
  const outEl = qs("out");
  const statusEl = qs("status");
  let LAST_INST = null;

  function setStatus(msg){ statusEl.textContent = "status: " + msg; }
  function pretty(obj){ try { return JSON.stringify(obj, null, 2); } catch(e){ return String(obj); } }

  async function api(path, { method="GET", json=null } = {}){
    const res = await fetch(path, {
      method,
      headers: json ? { "content-type":"application/json" } : {},
      body: json ? JSON.stringify(json) : undefined
    });
    const text = await res.text().catch(()=>"");
    let data = null;
    try { data = text ? JSON.parse(text) : null; } catch { data = text; }
    return { status: res.status, data };
  }

  function instIdOf(inst){
    return inst?.installation_id || inst?.id || inst?.installationId || null;
  }

  function pick(obj, paths){
    for (const p of paths){
      let cur = obj; let ok = true;
      for (const k of p){
        if (cur && Object.prototype.hasOwnProperty.call(cur, k)) cur = cur[k];
        else { ok = false; break; }
      }
      if (ok && cur !== undefined && cur !== null) return cur;
    }
    return null;
  }

  function unwrapSnapshot(s){
    let cur = s;
    for (let i=0;i<4;i++){
      if (!cur || typeof cur !== "object") break;
      if (cur.snapshot) cur = cur.snapshot;
      else if (cur.data) cur = cur.data;
      else if (cur.payload) cur = cur.payload;
      else break;
    }
    return cur;
  }

  function lastOf(v){
    if (Array.isArray(v) && v.length) return v[v.length-1];
    return v;
  }

  function extractCanSnapshot(inst){
    const candidates = [
      lastOf(pick(inst, [["can","snapshots"],["can","snapShots"]])),
      lastOf(pick(inst, [["can_snapshots"],["canSnapshots"]])),
      pick(inst, [["can_snapshot_latest"],["canSnapshotLatest"],["last_can_snapshot"],["lastCanSnapshot"]]),
      pick(inst, [["can_snapshot"],["canSnapshot"]]),
      lastOf(pick(inst, [["can_snapshots"],["canSnapshots"]])),
      lastOf(pick(inst, [["snapshots","can"],["snapshots","can_snapshots"],["snapshots","canSnapshots"]])),
      pick(inst, [["monitor","can_snapshot"],["monitor","snapshot"],["monitorSnapshot"]]),
      pick(inst, [["can"],["monitor_snapshot"]])
    ].filter((v)=>{ if(!v) return false; if (Array.isArray(v) && !v.length) return false; return true; });
    if (!candidates.length) return null;
    const c0 = candidates[0];
  const v0 = Array.isArray(c0) ? lastOf(c0) : c0;
  return unwrapSnapshot(v0);
  }


  // === CAN Snapshot render (raw_value) ===
  const canFilterEl = qs("canFilter");
  const paramsBodyEl = qs("tblParamsBody");
  const msBodyEl = qs("tblMsBody");
  const pillParamsEl = qs("pillParams");
  const pillParamsWithEl = qs("pillParamsWith");
  const pillMsEl = qs("pillMs");
  const probeScreenEl = qs("probeScreen");

  let __LAST_CAN = { params: [], ms: [] };


  // Configurável: adicione/remova aliases conforme sua validação CAN evoluir
  const PROBE_PARAM_ALIASES = {
    ignition: ["ignition", "ignition_status", "sys_param_ignition"],
    server_time: ["server_time"],
    progress: ["progress"],
    driver_code: ["driver_code", "driver id", "driver_id"],
    license_number: ["license_nmbr", "license_number", "license"],
    serial: ["inner_id", "serial"],
    client: ["vcl_client_description", "client_description", "client"],
    model: ["vcl_model", "model"]
  };

  // IDs preferenciais (mais confiável que nome)
  const PROBE_PARAM_IDS = {
    fuel_total_used: ["00000031", "000000C5"],
    fuel_level: ["00000032", "000000C3"],
    fuel_rate: ["0000003C"],
    oil_pressure: ["00000024", "0000010D"],
    oil_temp: ["0000168E"],
    coolant_temp: ["0000002F", "0000010E"],
    fuel_temp: ["0000002E", "0000010F"],
    odometer: ["00002714"],
    windshield: ["0000AF8C", "0000D419", "0000D41A"]
  };

  function normKey(s){
    return String(s == null ? "" : s).toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^a-z0-9]+/g, "");
  }
  function toBool01(v){
    if (v === true || v === false) return v;
    const s = String(v == null ? "" : v).trim().toLowerCase();
    if (["1","true","yes","y","ok","on","active"].includes(s)) return true;
    if (["0","false","no","n","off","inactive"].includes(s)) return false;
    return null;
  }
  function toIgnitionBool(v){
    const b = toBool01(v);
    if (b != null) return b;
    const s = String(v == null ? "" : v).trim();
    if (!s) return null;
    if (/^[0-9]+$/.test(s)) return Number(s) !== 0;
    if (/^[0-9a-fA-F]+$/.test(s)) {
      const n16 = parseInt(s, 16);
      if (Number.isFinite(n16)) return n16 !== 0;
    }
    return null;
  }
  function rowModuleName(r){
    return String(r?.name ?? r?.module_name ?? r?.moduleName ?? "").trim();
  }
  function rowModuleId(r){
    const v = r?.id ?? r?.module_id ?? r?.moduleId ?? null;
    const n = Number(v);
    return Number.isFinite(n) ? n : null;
  }
  function firstNonEmpty(values){
    for (const v of values){
      if (v == null) continue;
      const s = String(v).trim();
      if (s) return s;
    }
    return "—";
  }
  function rawParamValue(p){
    return firstNonEmpty([
      p?.raw_value,
      p?.rawValue,
      p?.raw?.value,
      p?.raw,
      p?.value,
      p?.val,
      p?.formatted_value,
      p?.formattedValue
    ]);
  }

  function normIdVariants(v){
    const out = new Set();
    if (v == null) return out;
    let s = String(v).trim().toUpperCase();
    if (!s) return out;
    s = s.replace(/^0X/, "");
    out.add(s);

    if (/^[0-9A-F]+$/.test(s)) {
      // Interpretando como HEX (caso comum no Monitor)
      const n16 = parseInt(s, 16);
      if (Number.isFinite(n16)) out.add(n16.toString(16).toUpperCase().padStart(8, "0"));
      // Se só dígitos, também tenta decimal (alguns payloads podem vir assim)
      if (/^[0-9]+$/.test(s)) {
        const n10 = parseInt(s, 10);
        if (Number.isFinite(n10)) out.add(n10.toString(16).toUpperCase().padStart(8, "0"));
      }
    } else if (/^[0-9]+$/.test(s)) {
      const n10 = parseInt(s, 10);
      if (Number.isFinite(n10)) out.add(n10.toString(16).toUpperCase().padStart(8, "0"));
    }
    return out;
  }

  function findParamByAliases(rows, aliases){
    const list = Array.isArray(rows) ? rows : [];
    const wants = (aliases || []).map(normKey).filter(Boolean);
    if (!wants.length) return null;

    let best = null;
    let bestScore = -1;
    for (const p of list){
      const nk = normKey(p?.name ?? "");
      if (!nk) continue;
      for (const w of wants){
        let score = -1;
        if (nk === w) score = 100;
        else if (nk.includes(w)) score = 70;
        else if (w.includes(nk) && nk.length >= 6) score = 60;
        if (score > bestScore){ bestScore = score; best = p; }
      }
    }
    return best;
  }

  function findParamByIds(rows, ids){
    const list = Array.isArray(rows) ? rows : [];
    const want = new Set();
    (ids || []).forEach(id => {
      for (const v of normIdVariants(id)) want.add(v);
    });
    if (!want.size) return null;

    for (const p of list){
      const pid = p?.id ?? p?.param_id ?? p?.parameter_id ?? p?.parameter?.id ?? p?.param?.id ?? p?.index;
      const vars = normIdVariants(pid);
      for (const v of vars){
        if (want.has(v)) return p;
      }
    }
    return null;
  }

  function getParamDisplay(rows, aliases){
    const p = findParamByAliases(rows, aliases);
    if (!p) return { ok:false, text:"—", row:null };
    const txt = firstNonEmpty([displayValue(p), rawParamValue(p)]);
    return { ok: txt !== "—", text: txt, row: p };
  }

  function getParamRawByIds(rows, ids, fallbackAliases){
    const p = findParamByIds(rows, ids) || findParamByAliases(rows, fallbackAliases || []);
    if (!p) return { ok:false, text:"—", row:null };
    const txt = rawParamValue(p);
    return { ok: txt !== "—", text: txt, row: p };
  }

  function findModule(msRows, ids, names){
    const rows = Array.isArray(msRows) ? msRows : [];
    const idsSet = new Set((ids||[]).map(Number).filter(Number.isFinite));
    const nameKeys = (names||[]).map(normKey).filter(Boolean);
    return rows.find(r => {
      const id = rowModuleId(r);
      const nk = normKey(rowModuleName(r));
      if (id != null && idsSet.has(id)) return true;
      if (nk && nameKeys.some(k => nk.includes(k))) return true;
      return false;
    }) || null;
  }

  function moduleChip(label, row){
    const ok = row ? (toBool01(row.ok) ?? toBool01(row.active) ?? toBool01(row.was_ok)) : null;
    const dot = ok === true ? "okDot" : ok === false ? "badDot" : "unkDot";
    const text = row ? `${label}:${ok===true?"OK":ok===false?"FAIL":"?"}` : `${label}:—`;
    return `<span class="pill"><span class="${dot}"></span>${esc(text)}</span>`;
  }

  function commModules(msRows){
    const can0 = findModule(msRows, [8], ["can0"]);
    const can1 = findModule(msRows, [9], ["can1"]);
    const j1708 = findModule(msRows, [15], ["j1708"]);
    const dallas = findModule(msRows, [19], ["dallas", "ibutton"]);
    const ramzor = findModule(msRows, [20], ["ramzor"]);
    const detail = [can0, can1, j1708].map(r => {
      if (!r) return "—";
      const id = rowModuleId(r);
      const ok = (toBool01(r?.ok) ?? toBool01(r?.active) ?? toBool01(r?.was_ok));
      return `id ${id}:${ok===true?"OK":ok===false?"FAIL":"?"}`;
    }).join(" | ");
    return { can0, can1, j1708, dallas, ramzor, detail };
  }

  function getHeaderLite(inst, snap, rows){
    const h = pick(snap || {}, [["header"],["headerLite"],["meta","header"],["summary","header"]]) || {};

    const ignP = getParamDisplay(rows, PROBE_PARAM_ALIASES.ignition);
    const progressP = getParamDisplay(rows, PROBE_PARAM_ALIASES.progress);
    const driverP = getParamDisplay(rows, PROBE_PARAM_ALIASES.driver_code);
    const licP = getParamDisplay(rows, PROBE_PARAM_ALIASES.license_number);
    const serialP = getParamDisplay(rows, PROBE_PARAM_ALIASES.serial);
    const clientP = getParamDisplay(rows, PROBE_PARAM_ALIASES.client);
    const modelP = getParamDisplay(rows, PROBE_PARAM_ALIASES.model);
    const serverTimeP = getParamDisplay(rows, PROBE_PARAM_ALIASES.server_time);

    return {
      ignition: firstNonEmpty([h.ignition, h.ignition_status, ignP.text]),
      communication: firstNonEmpty([h.server_time, h.serverTime, snap?.server_time, serverTimeP.text, snap?.captured_at]),
      progress: firstNonEmpty([progressP.text, h.progress, h.configuration_progress, inst?.status]),
      driver_code: firstNonEmpty([driverP.text, h.driver_code, h.driverCode]),
      license_number: firstNonEmpty([licP.text, h.license_nmbr, h.license_number]),
      serial: firstNonEmpty([serialP.text, h.inner_id, h.serial]),
      client: firstNonEmpty([clientP.text, h.vcl_client_description, h.client, h.client_name]),
      model: firstNonEmpty([modelP.text, h.vcl_model, h.model])
    };
  }

  function probeLine(label, param){
    const cls = (param && param.ok) ? "probeItem" : "probeItem miss";
    return `<div class="${cls}"><span class="k">${esc(label)}:</span> <span class="v">[${esc(param ? param.text : "—")}]</span></div>`;
  }

  function ignitionLamp(value){
    const on = toIgnitionBool(value);
    const dot = on === true ? "okDot" : on === false ? "badDot" : "unkDot";
    return `<span class="${dot}"></span>${esc(String(value ?? "—"))}`;
  }

  function renderProbeScreen(inst, snap, x){
    if (!probeScreenEl) return;
    const rows = (x && x.params) || [];
    const msRows = (x && x.ms) || [];
    const comm = commModules(msRows);
    const header = getHeaderLite(inst, snap, rows);

    // CAN params por ID (mostrar raw_value)
    const fuelTotal   = getParamRawByIds(rows, PROBE_PARAM_IDS.fuel_total_used, ["engine_total_fuel_used"]);
    const fuelLvl     = getParamRawByIds(rows, PROBE_PARAM_IDS.fuel_level, ["fuel_level_1"]);
    const fuelRate    = getParamRawByIds(rows, PROBE_PARAM_IDS.fuel_rate, ["engine_fuel_rate"]);
    const oilPressure = getParamRawByIds(rows, PROBE_PARAM_IDS.oil_pressure, ["engine_oil_pressure"]);
    const oilTemp     = getParamRawByIds(rows, PROBE_PARAM_IDS.oil_temp, ["engine_oil_temperature_1"]);
    const coolantTemp = getParamRawByIds(rows, PROBE_PARAM_IDS.coolant_temp, ["engine_coolant_temperature"]);
    const fuelTemp    = getParamRawByIds(rows, PROBE_PARAM_IDS.fuel_temp, ["engine_fuel_temperature_1"]);
    const odometer    = getParamRawByIds(rows, PROBE_PARAM_IDS.odometer, ["sys_param_vehicle_distance"]);
    const windshield  = getParamRawByIds(rows, PROBE_PARAM_IDS.windshield, ["arm_analog_input_3"]);

    probeScreenEl.innerHTML = `
      <div class="probeRow">
        <div class="probeBox"><b>ignition</b><br>${ignitionLamp(header.ignition)}</div>
        <div class="probeBox"><b>communication</b><br>${esc(header.communication)}</div>
      </div>
      <div class="probeRow">
        <div class="probeBox"><b>progress</b><br>${esc(header.progress)}</div>
        <div class="probeBox"><b>driver code</b><br>${esc(header.driver_code)}</div>
      </div>
      <div class="probeRow">
        <div class="probeBox"><b>[license number]</b> ${esc(header.license_number)}</div>
        <div class="probeBox"><b>serial</b> ${esc(header.serial)}</div>
      </div>
      <div class="probeRow">
        <div class="probeBox"><b>client</b> ${esc(header.client)}</div>
        <div class="probeBox"><b>model</b> ${esc(header.model)}</div>
      </div>

      <div class="kv" style="margin:4px 0 8px">
        ${moduleChip("CAN0", comm.can0)}
        ${moduleChip("CAN1", comm.can1)}
        ${moduleChip("J1708", comm.j1708)}
        ${moduleChip("Dallas", comm.dallas)}
        ${moduleChip("Ramzor", comm.ramzor)}
      </div>

      <div class="probeBig">
        <div class="probeSectionTitle">FUEL</div>
        ${probeLine("engine_total_fuel_used", fuelTotal)}
        ${probeLine("fuel_level_1", fuelLvl)}
        ${probeLine("engine_fuel_rate", fuelRate)}

        <div class="probeSectionTitle">PRESSURE</div>
        ${probeLine("engine_oil_pressure", oilPressure)}

        <div class="probeSectionTitle">TEMPERATURE</div>
        ${probeLine("engine_oil_temperature_1", oilTemp)}
        ${probeLine("engine_coolant_temperature", coolantTemp)}
        ${probeLine("engine_fuel_temperature_1", fuelTemp)}

        <div class="probeSectionTitle">ODOMETER</div>
        ${probeLine("sys_param_vehicle_distance", odometer)}

        <div class="probeSectionTitle">WINDSHIELD</div>
        ${probeLine("arm_analog_input_3", windshield)}

        <div class="probeLegend">${esc(comm.detail)}</div>
      </div>
    `;
  }

  function renderCanSnapshot(snap){
    const x = extractRowsFromSnapshot(snap);
    __LAST_CAN = x;

    const withValue = x.params.filter(p => displayValue(p).trim() !== "").length;

    pillParamsEl.textContent = `params: ${x.params.length}`;
    pillParamsWithEl.textContent = `com valor: ${withValue}`;
    pillMsEl.textContent = `module: ${x.ms.length}`;

    try { renderProbeScreen(LAST_INST, snap, x); } catch(_e) {}
    renderParamsTable(x.params, (canFilterEl && canFilterEl.value) ? canFilterEl.value : "");
    renderMsTable(x.ms);
  }

  if (canFilterEl){
    canFilterEl.addEventListener("input", () => {
      renderParamsTable(__LAST_CAN.params, canFilterEl.value);
    });
  }


  async function loadInstallation(id){
    setStatus("carregando...");
    const r = await api(`/api/installations/${encodeURIComponent(id)}`);
    if (r.status === 200 && r.data){
      const inst = r.data;
      LAST_INST = inst;
      const snap = extractCanSnapshot(inst);
      
      
          renderCanSnapshot(snap);
outEl.textContent = pretty({ installation: inst, can_snapshot: snap });
      qs("installation_id").value = instIdOf(inst) || id;
      localStorage.setItem("can_probe_last_installation_id", instIdOf(inst) || id);

      const st = (inst && inst.status) ? String(inst.status) : "ok";
      setStatus(st);
    } else {
      outEl.textContent = pretty(r);
      if (r.status === 404){
        // id antigo no localStorage costuma causar confusão
        try { localStorage.removeItem("can_probe_last_installation_id"); } catch(_){}
        setStatus("installation_id não encontrado (limpei o cache local)");
      } else {
        setStatus("erro ao carregar");
      }
    }
    return r;
  }

  async function createProbe(){
    const vehicleId = qs("vehicle_id").value.trim();
    if (!vehicleId) return setStatus("informe vehicle_id");
    setStatus("criando CAN_PROBE...");
    const payload = {
      service: "CAN_PROBE",
      vehicle_id: vehicleId,
      vehicleId: vehicleId,
      target_client_id: qs("target_client_id").value.trim() || null,
      vehicleSettingId: qs("vehicleSettingId").value.trim() || null,
      comments: qs("comments").value || null,
      installationDate: new Date().toISOString()
    };
    const r = await api("/api/installations", { method:"POST", json: payload });
    outEl.textContent = pretty(r);
    if (r.status === 201 && r.data){
      const id = instIdOf(r.data);
      if (id){
        qs("installation_id").value = id;
        setStatus("criado — carregando...");
        await loadInstallation(id);
      } else {
        setStatus("criado (sem id no retorno)");
      }
    } else {
      setStatus("erro ao criar");
    }
  }

  async function requestSnapshot(){
    const id = qs("installation_id").value.trim();
    if (!id) return setStatus("informe installation_id");

    // resolve vehicle_id: input -> last loaded installation -> payload
    let vehicle_id = Number(qs("vehicle_id").value.trim());
    if (!Number.isFinite(vehicle_id) || vehicle_id <= 0){
      const v = pick(LAST_INST, [
        ["resolved","vehicle_id"],
        ["payload","vehicle_id"],
        ["payload","vehicleId"],
        ["vehicle_id"],
        ["vehicleId"]
      ]);
      vehicle_id = (v != null) ? Number(v) : NaN;
    }
    if (!Number.isFinite(vehicle_id) || vehicle_id <= 0){
      return setStatus("informe vehicle_id (input ou payload/resolved)");
    }

    setStatus("request snapshot...");
    const r = await api(`/api/installations/${encodeURIComponent(id)}/actions/request-can-snapshot`, {
      method:"POST",
      json:{ vehicle_id }
    });

    // mostra resposta do POST (útil p/ headers/erros)
    outEl.textContent = pretty({ request: r });

    if (r.status >= 400){
      setStatus("erro no request snapshot");
      return;
    }

    // polling: esperar backend preencher can.summary/snapshots
    await pollCan(id);
  }

  async function pollCan(id, { tries=180, sleepMs=2000 } = {}){
    for (let i=0; i<tries; i++){
      const r = await api(`/api/installations/${encodeURIComponent(id)}`);
      if (r.status === 200 && r.data){
        const inst = r.data;
        LAST_INST = inst;
        const snap = extractCanSnapshot(inst);
        try { renderCanSnapshot(snap); } catch(_e) {}
        outEl.textContent = pretty({
          poll: { attempt: i+1, tries, inst_status: inst.status || null },
          inst: { installation_id: instIdOf(inst), status: inst.status || null, jobs: (inst.jobs||[]).slice(-3) },
          snap_counts: (snap && snap.counts) ? snap.counts : null
        });
const hasSummary = !!(snap && snap.summary);
        const hasList = !!(snap && Array.isArray(snap.snapshots) && snap.snapshots.length);
        const hasCounts = !!(snap && snap.counts && ((snap.counts.params_total||0)>0 || (snap.counts.module_total||0)>0));
        const hasParams = !!(snap && Array.isArray(snap.parameters) && snap.parameters.length);
        const hasModule = !!(snap && Array.isArray(snap.moduleState) && snap.moduleState.length);
        const statusReady = String(inst.status || "") === "CAN_SNAPSHOT_READY";
        if (statusReady || hasSummary || hasList || hasCounts || hasParams || hasModule){
          const p = (snap && snap.counts && (snap.counts.params_total||snap.counts.paramsTotal)) || (snap && snap.parameters && snap.parameters.length) || 0;
          const m = (snap && snap.counts && (snap.counts.module_total||snap.counts.moduleTotal)) || (snap && snap.moduleState && snap.moduleState.length) || 0;
          setStatus(`CAN pronto ✅ (params=${p}, modules=${m})`);
          return r;
        }
      } else {
        outEl.textContent = pretty({ poll: { attempt: i+1, tries }, error: r });
      }

      setStatus(`aguardando CAN... (${i+1}/${tries})`);
      await new Promise(res => setTimeout(res, sleepMs));
    }
    setStatus("timeout aguardando CAN — use Carregar");
    return null;
  }

async function approveCan(){
    const id = qs("installation_id").value.trim();
    if (!id) return setStatus("informe installation_id");
    setStatus("aprovando CAN...");
    const r = await api(`/api/installations/${encodeURIComponent(id)}/actions/approve-can`, { method:"POST", json:{} });
    outEl.textContent = pretty(r);
    await loadInstallation(id);
  }

  qs("btnCreate").addEventListener("click", createProbe);
  qs("btnReq").addEventListener("click", requestSnapshot);
  qs("btnLoad").addEventListener("click", () => loadInstallation(qs("installation_id").value.trim()));
  qs("btnApprove").addEventListener("click", approveCan);

  const last = localStorage.getItem("can_probe_last_installation_id");
  if (last){
    qs("installation_id").value = last;
    loadInstallation(last).catch(()=>{});
  }
</script>
</body>
</html>
