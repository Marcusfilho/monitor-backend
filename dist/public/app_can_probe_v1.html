
<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>CAN Probe — Vehicle Monitor snapshot</title>
  <style>
    :root{
      --bg:#0b0f12; --panel:#0f1620; --muted:#93a4b8; --text:#e8eef2; --line:#1f2a38;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--text);font-family:var(--sans)}
    header{padding:16px 18px;border-bottom:1px solid var(--line);display:flex;gap:12px;align-items:center;justify-content:space-between}
    header h1{margin:0;font-size:16px;font-weight:700}
    header .nav{display:flex;gap:10px;align-items:center;font-size:12px}
    header a{color:#cfe6ff;text-decoration:none;border:1px solid var(--line);padding:6px 10px;border-radius:10px;background:#0b1118}
    .wrap{padding:16px 18px}
    .grid{display:grid;grid-template-columns: 420px 1fr; gap:14px; align-items:start}
    .card{background:var(--panel);border:1px solid var(--line);border-radius:14px;padding:14px}
    .card h2{margin:0 0 10px 0;font-size:13px;color:#cfe6ff}
    label{display:block;font-size:12px;color:var(--muted);margin:10px 0 6px}
    input, textarea{
      width:100%;padding:10px 12px;border-radius:12px;border:1px solid #273245;background:#0b1118;color:var(--text);outline:none;
      font-family:var(--sans);font-size:13px
    }
    textarea{min-height:70px;resize:vertical}
    button{
      cursor:pointer;border:1px solid #2a3a52;background:#122033;color:#e8eef2;border-radius:12px;padding:10px 12px;font-weight:650;
    }
    button:hover{border-color:#3b5478}
    button.secondary{background:#0b1118}
    .btnrow{display:flex;gap:10px;flex-wrap:wrap}
    .hint{font-size:12px;color:var(--muted);line-height:1.4;margin-top:10px}
    .status{font-family:var(--mono);font-size:12px;color:var(--muted);margin-top:10px}
    pre{
      margin:0; padding:12px; border-radius:14px; border:1px solid #273245;
      background:#000; color:#e8eef2; font-family:var(--mono); font-size:12px; line-height:1.35;
      overflow:auto; max-height: 74vh;
    }
  
    /* === CAN Snapshot UI (raw_value) === */
    .kv{font-size:12px;color:var(--muted);margin:8px 0 10px;display:flex;gap:10px;flex-wrap:wrap}
    .pill{border:1px solid #273245;background:#0b1118;padding:4px 8px;border-radius:999px}
    .tableWrap{border:1px solid #273245;border-radius:14px;overflow:auto;max-height:32vh;background:#000}
    table{width:100%;border-collapse:collapse;font-family:var(--mono);font-size:12px}
    th,td{padding:7px 10px;border-bottom:1px solid #1f2a38;vertical-align:top}
    th{position:sticky;top:0;background:#0b1118;color:#cfe6ff}
    tr:hover td{background:#0b1118}
    details summary{cursor:pointer;color:#cfe6ff;font-size:12px;margin:10px 0}
  

    /* === Probe screen (validação CAN) === */
    .probeScreen{
      background:#000;border:1px solid #273245;border-radius:20px;padding:10px; margin:8px 0 12px;
      font-family:var(--mono); color:#f4f7fb;
    }
    .probeRow{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:8px}
    .probeBox{
      border:1px solid #25b5ff; border-radius:10px; padding:6px 8px; min-height:42px;
      display:flex; align-items:center; justify-content:center; text-align:center;
      background:#02070b;
      font-size:11px; line-height:1.25;
    }
    .probeBox b{color:#fff; font-weight:700}
    .probeBig{
      border:1px solid #25b5ff; border-radius:26px; padding:14px 16px; background:#02070b;
      min-height:260px;
    }
    .probeSectionTitle{color:#fff;font-weight:700;margin:8px 0 4px 0;font-size:12px}
    .probeItem{margin:2px 0; color:#dfeaf7; font-size:11px}
    .probeItem .k{display:inline-block; min-width:132px; color:#dfeaf7}
    .probeItem .v{color:#fff; font-style:italic}
    .probeItem.miss .v{color:#9aaabd}
    .probeLegend{font-size:11px;color:#93a4b8;margin:8px 0 0}
    .okDot,.badDot,.unkDot{
      display:inline-block; width:8px; height:8px; border-radius:999px; margin-right:6px; vertical-align:middle;
    }
    .okDot{background:#36d66b}
    .badDot{background:#ff6161}
    .unkDot{background:#93a4b8}

</style>
</head>
<body>
<header>
  <h1>CAN Probe <span style="opacity:.8;font-size:12px">— cria instalação CAN_PROBE e puxa snapshot</span></h1>
  <div class="nav">
    <a href="/app/app_installations_v2.html">Voltar (v2)</a>
    <a href="/app/app_installations_v1.html">v1</a>
  </div>
</header>

<div class="wrap">
  <div class="grid">
    <div class="card">
      <h2>1) Criar “instalação probe” (sem HTML5/SB)</h2>

      <label>vehicle_id (real, online)</label>
      <input id="vehicle_id" placeholder="ex.: 1940478" />

      <label>target_client_id (opcional)</label>
      <input id="target_client_id" placeholder="ex.: 218572" />

      <label>vehicleSettingId (opcional)</label>
      <input id="vehicleSettingId" placeholder="ex.: 5592" />

      <label>comments (opcional)</label>
      <textarea id="comments" placeholder="ex.: CAN PROBE..."></textarea>

      <div class="btnrow" style="margin-top:12px">
        <button id="btnCreate">Criar CAN_PROBE</button>
        <button class="secondary" id="btnReq">Request snapshot</button>
        <button class="secondary" id="btnLoad">Carregar</button>
        <button class="secondary" id="btnApprove">Aprovar CAN</button>
      </div>

      <hr style="border:none;border-top:1px solid var(--line);margin:14px 0" />

      <h2>2) Ou inspecionar um installation_id existente</h2>
      <label>installation_id</label>
      <input id="installation_id" placeholder="inst_..." />

      <div class="hint">
        <div>• Esse probe depende do backend aceitar <b>service=CAN_PROBE</b> sem enfileirar job HTML5.</div>
        <div>• Depois você usa <b>Request snapshot</b> e vai recarregando até aparecer CAN.</div>
      </div>

      <div class="status" id="status">status: pronto</div>
    </div>

    <div class="card">
      <h2>CAN Probe (validação)</h2>
      <div class="kv" id="canSummary">
        <span class="pill">snapshot: —</span>
        <span class="pill" id="pillParams">params: 0</span>
        <span class="pill" id="pillParamsWith">com valor: 0</span>
        <span class="pill" id="pillMs">module: 0</span>
      </div>

      <div id="probeScreen" class="probeScreen">aguardando snapshot...</div>

      <details>
        <summary>Debug / Parameters / Module State</summary>

        <label style="margin-top:8px">Filtro (Parameters)</label>
        <input id="canFilter" placeholder="filtrar por name / id / type..." />

        <div class="muted" style="font-size:12px;color:var(--muted);margin:10px 0 6px">Parameters</div>
        <div class="tableWrap">
          <table>
            <thead>
              <tr><th>name</th><th>type</th><th>value (value/raw_value)</th><th>last_update</th><th>source</th></tr>
            </thead>
            <tbody id="tblParamsBody"></tbody>
          </table>
        </div>

        <div class="muted" style="font-size:12px;color:var(--muted);margin:12px 0 6px">Module State</div>
        <div class="tableWrap">
          <table>
            <thead>
              <tr><th>id</th><th>name</th><th>active</th><th>ok</th><th>was_ok</th><th>message</th></tr>
            </thead>
            <tbody id="tblMsBody"></tbody>
          </table>
        </div>

        <details>
          <summary>JSON (inst + snapshot)</summary>
          <pre id="out">{}</pre>
        </details>
      </details>
    </div>
  </div>
</div>

<script>
  const qs = (id) => document.getElementById(id);
  const outEl = qs("out");
  const statusEl = qs("status");
  let LAST_INST = null;

  function setStatus(msg){ statusEl.textContent = "status: " + msg; }
  function pretty(obj){ try { return JSON.stringify(obj, null, 2); } catch(e){ return String(obj); } }

  async function api(path, { method="GET", json=null } = {}){
    const res = await fetch(path, {
      method,
      headers: json ? { "content-type":"application/json" } : {},
      body: json ? JSON.stringify(json) : undefined
    });
    const text = await res.text().catch(()=>"");
    let data = null;
    try { data = text ? JSON.parse(text) : null; } catch { data = text; }
    return { status: res.status, data };
  }

  function instIdOf(inst){
    return inst?.installation_id || inst?.id || inst?.installationId || null;
  }

  function pick(obj, paths){
    for (const p of paths){
      let cur = obj; let ok = true;
      for (const k of p){
        if (cur && Object.prototype.hasOwnProperty.call(cur, k)) cur = cur[k];
        else { ok = false; break; }
      }
      if (ok && cur !== undefined && cur !== null) return cur;
    }
    return null;
  }

  function unwrapSnapshot(s){
    let cur = s;
    for (let i=0;i<4;i++){
      if (!cur || typeof cur !== "object") break;
      if (cur.snapshot) cur = cur.snapshot;
      else if (cur.data) cur = cur.data;
      else if (cur.payload) cur = cur.payload;
      else break;
    }
    return cur;
  }

  function lastOf(v){
    if (Array.isArray(v) && v.length) return v[v.length-1];
    return v;
  }

  function extractCanSnapshot(inst){
    const candidates = [
      lastOf(pick(inst, [["can","snapshots"],["can","snapShots"]])),
      lastOf(pick(inst, [["can_snapshots"],["canSnapshots"]])),
      pick(inst, [["can_snapshot_latest"],["canSnapshotLatest"],["last_can_snapshot"],["lastCanSnapshot"]]),
      pick(inst, [["can_snapshot"],["canSnapshot"]]),
      lastOf(pick(inst, [["can_snapshots"],["canSnapshots"]])),
      lastOf(pick(inst, [["snapshots","can"],["snapshots","can_snapshots"],["snapshots","canSnapshots"]])),
      pick(inst, [["monitor","can_snapshot"],["monitor","snapshot"],["monitorSnapshot"]]),
      pick(inst, [["can"],["monitor_snapshot"]])
    ].filter((v)=>{ if(!v) return false; if (Array.isArray(v) && !v.length) return false; return true; });
    if (!candidates.length) return null;
    const c0 = candidates[0];
  const v0 = Array.isArray(c0) ? lastOf(c0) : c0;
  return unwrapSnapshot(v0);
  }


  // === CAN Snapshot render (raw_value) ===
  const canFilterEl = qs("canFilter");
  const paramsBodyEl = qs("tblParamsBody");
  const msBodyEl = qs("tblMsBody");
  const pillParamsEl = qs("pillParams");
  const pillParamsWithEl = qs("pillParamsWith");
  const pillMsEl = qs("pillMs");
  const probeScreenEl = qs("probeScreen");

  let __LAST_CAN = { params: [], ms: [] };

  const PROBE_SNAPSHOT_REQ = {
    cycles: 8,
    interval_ms: 6000,
    // força varrer mais ciclos (worker respeita isso após patch do Bloco C)
    early_stop_min_total: 9999,
    early_stop_min_with: 9999
  };
  const PROBE_POLL_OPTS = { tries: 360, sleepMs: 2000 };



  // Configurável: adicione/remova aliases conforme sua validação CAN evoluir
  const PROBE_PARAM_ALIASES = {
    ignition: ["ignition", "ignition_status", "sys_param_ignition"],
    server_time: ["server_time"],
    progress: ["progress"],
    driver_code: ["driver_code", "driver id", "driver_id"],
    license_number: ["license_nmbr", "license_number", "license"],
    serial: ["inner_id", "serial"],
    client: ["vcl_client_description", "client_description", "client"],
    model: ["vcl_model", "model"]
  };

  // IDs preferenciais (mais confiável que nome)
  const PROBE_PARAM_IDS = {
    fuel_total_used: ["00000031", "000000C5"],
    fuel_level: ["00000032", "000000C3"],
    fuel_rate: ["0000003C"],
    oil_pressure: ["00000024", "0000010D"],
    oil_temp: ["0000168E"],
    coolant_temp: ["0000002F", "0000010E"],
    fuel_temp: ["0000002E", "0000010F"],
    odometer: ["00002714"],
    windshield: ["0000AF8C", "0000D419", "0000D41A"]
  };

  function normKey(s){
    return String(s == null ? "" : s).toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^a-z0-9]+/g, "");
  }
  function toBool01(v){
    if (v === true || v === false) return v;
    const s = String(v == null ? "" : v).trim().toLowerCase();
    if (["1","true","yes","y","ok","on","active"].includes(s)) return true;
    if (["0","false","no","n","off","inactive"].includes(s)) return false;
    return null;
  }
  function toIgnitionBool(v){
    const b = toBool01(v);
    if (b != null) return b;
    const s = String(v == null ? "" : v).trim();
    if (!s) return null;
    if (/^[0-9]+$/.test(s)) return Number(s) !== 0;
    if (/^[0-9a-fA-F]+$/.test(s)) {
      const n16 = parseInt(s, 16);
      if (Number.isFinite(n16)) return n16 !== 0;
    }
    return null;
  }
  function rowModuleName(r){
    return String(r?.name ?? r?.module_name ?? r?.moduleName ?? "").trim();
  }
  function rowModuleId(r){
    const v = r?.id ?? r?.module_id ?? r?.moduleId ?? null;
    const n = Number(v);
    return Number.isFinite(n) ? n : null;
  }
  function firstNonEmpty(values){
    for (const v of values){
      if (v == null) continue;
      const s = String(v).trim();
      if (s) return s;
    }
    return "—";
  }
  function rawParamValue(p){
    return firstNonEmpty([
      p?.raw_value,
      p?.rawValue,
      p?.raw?.value,
      p?.raw,
      p?.value,
      p?.val,
      p?.formatted_value,
      p?.formattedValue
    ]);
  }

  function normIdVariants(v){
    const out = new Set();
    if (v == null) return out;
    let s = String(v).trim().toUpperCase();
    if (!s) return out;
    s = s.replace(/^0X/, "");
    out.add(s);

    if (/^[0-9A-F]+$/.test(s)) {
      // Interpretando como HEX (caso comum no Monitor)
      const n16 = parseInt(s, 16);
      if (Number.isFinite(n16)) out.add(n16.toString(16).toUpperCase().padStart(8, "0"));
      // Se só dígitos, também tenta decimal (alguns payloads podem vir assim)
      if (/^[0-9]+$/.test(s)) {
        const n10 = parseInt(s, 10);
        if (Number.isFinite(n10)) out.add(n10.toString(16).toUpperCase().padStart(8, "0"));
      }
    } else if (/^[0-9]+$/.test(s)) {
      const n10 = parseInt(s, 10);
      if (Number.isFinite(n10)) out.add(n10.toString(16).toUpperCase().padStart(8, "0"));
    }
    return out;
  }

  function findParamByAliases(rows, aliases){
    const list = Array.isArray(rows) ? rows : [];
    const wants = (aliases || []).map(normKey).filter(Boolean);
    if (!wants.length) return null;

    let best = null;
    let bestScore = -1;
    for (const p of list){
      const nk = normKey(p?.name ?? "");
      if (!nk) continue;
      for (const w of wants){
        let score = -1;
        if (nk === w) score = 100;
        else if (nk.includes(w)) score = 70;
        else if (w.includes(nk) && nk.length >= 6) score = 60;
        if (score > bestScore){ bestScore = score; best = p; }
      }
    }
    return best;
  }

  function findParamByIds(rows, ids){
    const list = Array.isArray(rows) ? rows : [];
    const want = new Set();
    (ids || []).forEach(id => {
      for (const v of normIdVariants(id)) want.add(v);
    });
    if (!want.size) return null;

    for (const p of list){
      const pid = p?.id ?? p?.param_id ?? p?.parameter_id ?? p?.parameter?.id ?? p?.param?.id ?? p?.index;
      const vars = normIdVariants(pid);
      for (const v of vars){
        if (want.has(v)) return p;
      }
    }
    return null;
  }

  function getParamDisplay(rows, aliases){
    const p = findParamByAliases(rows, aliases);
    if (!p) return { ok:false, text:"—", row:null };
    const txt = firstNonEmpty([displayValue(p), rawParamValue(p)]);
    return { ok: txt !== "—", text: txt, row: p };
  }

  function getParamRawByIds(rows, ids, fallbackAliases){
    const p = findParamByIds(rows, ids) || findParamByAliases(rows, fallbackAliases || []);
    if (!p) return { ok:false, text:"—", row:null };
    const txt = rawParamValue(p);
    return { ok: txt !== "—", text: txt, row: p };
  }

  function findModule(msRows, ids, names){
    const rows = Array.isArray(msRows) ? msRows : [];
    const idsSet = new Set((ids||[]).map(Number).filter(Number.isFinite));
    const nameKeys = (names||[]).map(normKey).filter(Boolean);
    return rows.find(r => {
      const id = rowModuleId(r);
      const nk = normKey(rowModuleName(r));
      if (id != null && idsSet.has(id)) return true;
      if (nk && nameKeys.some(k => nk.includes(k))) return true;
      return false;
    }) || null;
  }

  function moduleChip(label, row){
    const ok = row ? (toBool01(row.ok) ?? toBool01(row.active) ?? toBool01(row.was_ok)) : null;
    const dot = ok === true ? "okDot" : ok === false ? "badDot" : "unkDot";
    const text = row ? `${label}:${ok===true?"OK":ok===false?"FAIL":"?"}` : `${label}:—`;
    return `<span class="pill"><span class="${dot}"></span>${esc(text)}</span>`;
  }

  function commModules(msRows){
    const can0 = findModule(msRows, [8], ["can0"]);
    const can1 = findModule(msRows, [9], ["can1"]);
    const j1708 = findModule(msRows, [15], ["j1708"]);
    const dallas = findModule(msRows, [19], ["dallas", "ibutton"]);
    const ramzor = findModule(msRows, [20], ["ramzor"]);
    const detail = [can0, can1, j1708].map(r => {
      if (!r) return "—";
      const id = rowModuleId(r);
      const ok = (toBool01(r?.ok) ?? toBool01(r?.active) ?? toBool01(r?.was_ok));
      return `id ${id}:${ok===true?"OK":ok===false?"FAIL":"?"}`;
    }).join(" | ");
    return { can0, can1, j1708, dallas, ramzor, detail };
  }


  function fmtProbeDateTime(v){
    const s = String(v == null ? "" : v).trim();
    if (!s) return "—";
    // ISO => "YYYY-MM-DD HH:MM:SS"
    if (/^\d{4}-\d{2}-\d{2}T/.test(s)) {
      return s.replace("T"," ").replace(/\.\d+Z?$/,"").replace(/Z$/,"");
    }
    return s;
  }

  function deepFindValue(root, keys, maxDepth=6){
    const wants = new Set((keys || []).map(k => String(k)));
    if (!root || !wants.size) return null;

    const q = [{ v: root, d: 0 }];
    const seen = new Set();

    while (q.length){
      const cur = q.shift();
      const v = cur.v;
      const d = cur.d;
      if (!v || typeof v !== "object") continue;
      if (seen.has(v)) continue;
      seen.add(v);

      if (Array.isArray(v)){
        if (d >= maxDepth) continue;
        for (let i=0; i<Math.min(v.length, 50); i++){
          q.push({ v: v[i], d: d+1 });
        }
        continue;
      }

      // match direto por chave
      for (const k of wants){
        if (Object.prototype.hasOwnProperty.call(v, k)){
          const x = v[k];
          if (x != null && (typeof x !== "object" || x instanceof Date)){
            const s = String(x).trim();
            if (s) return x;
          }
        }
      }

      if (d >= maxDepth) continue;
      for (const k of Object.keys(v)){
        const x = v[k];
        if (x && typeof x === "object"){
          q.push({ v: x, d: d+1 });
        }
      }
    }
    return null;
  }

  function getHeaderLite(inst, snap, rows){
    const ignP = getParamDisplay(rows, PROBE_PARAM_ALIASES.ignition);
    const progressP = getParamDisplay(rows, PROBE_PARAM_ALIASES.progress);
    const driverP = getParamDisplay(rows, PROBE_PARAM_ALIASES.driver_code);
    const licP = getParamDisplay(rows, PROBE_PARAM_ALIASES.license_number);
    const serialP = getParamDisplay(rows, PROBE_PARAM_ALIASES.serial);
    const clientP = getParamDisplay(rows, PROBE_PARAM_ALIASES.client);
    const modelP = getParamDisplay(rows, PROBE_PARAM_ALIASES.model);
    const serverTimeP = getParamDisplay(rows, PROBE_PARAM_ALIASES.server_time);

    const ignRaw = deepFindValue(snap, ["ignition","ignition_status","sys_param_ignition"]) ?? deepFindValue(inst, ["ignition","ignition_status","sys_param_ignition"]);
    const progressRaw = deepFindValue(snap, ["progress","configuration_progress","configurationProgress"]) ?? deepFindValue(inst, ["progress","configuration_progress","configurationProgress"]);
    const driverRaw = deepFindValue(snap, ["driver_code","driverCode"]) ?? deepFindValue(inst, ["driver_code","driverCode"]);
    const licRaw = deepFindValue(snap, ["license_nmbr","license_number","license"]) ?? deepFindValue(inst, ["license_nmbr","license_number","license"]);
    const serialRaw = deepFindValue(snap, ["inner_id","innerId","serial"]) ?? deepFindValue(inst, ["inner_id","innerId","serial"]);
    const clientRaw = deepFindValue(snap, ["vcl_client_description","client_description","client","client_name"]) ?? deepFindValue(inst, ["vcl_client_description","client_description","client","client_name"]);
    const modelRaw = deepFindValue(snap, ["vcl_model","model"]) ?? deepFindValue(inst, ["vcl_model","model"]);
    const serverTimeRaw = deepFindValue(snap, ["server_time","serverTime"]) ?? deepFindValue(inst, ["server_time","serverTime"]);

    const progressTxt = (() => {
      const v = firstNonEmpty([progressRaw, progressP.text, inst?.status]);
      if (v === "—") return v;
      const s = String(v).trim();
      // se vier 0..100 puro, mostra %
      if (/^\d{1,3}$/.test(s)) return s + "%";
      return s;
    })();

    return {
      ignition: firstNonEmpty([ignRaw, ignP.text]),
      communication: fmtProbeDateTime(firstNonEmpty([serverTimeRaw, serverTimeP.text, snap?.captured_at])),
      progress: progressTxt,
      driver_code: firstNonEmpty([driverRaw, driverP.text]),
      license_number: firstNonEmpty([licRaw, licP.text]),
      serial: firstNonEmpty([serialRaw, serialP.text]),
      client: firstNonEmpty([clientRaw, clientP.text]),
      model: firstNonEmpty([modelRaw, modelP.text])
    };
  }

  function probeLine(label, param){
    const cls = (param && param.ok) ? "probeItem" : "probeItem miss";
    return `<div class="${cls}"><span class="k">${esc(label)}:</span> <span class="v">[${esc(param ? param.text : "—")}]</span></div>`;
  }

  function ignitionLamp(value){
    const on = toIgnitionBool(value);
    const dot = on === true ? "okDot" : on === false ? "badDot" : "unkDot";
    const txt = on === true ? "1" : (on === false ? "0" : "—");
    return `<span class="${dot}"></span>${txt}`;
  }

  function renderProbeScreen(inst, snap, x){
    if (!probeScreenEl) return;
    const rows = (x && x.params) || [];
    const msRows = (x && x.ms) || [];
    const comm = commModules(msRows);
    const header = getHeaderLite(inst, snap, rows);

    // CAN params por ID (mostrar raw_value)
    const fuelTotal   = getParamRawByIds(rows, PROBE_PARAM_IDS.fuel_total_used, ["engine_total_fuel_used"]);
    const fuelLvl     = getParamRawByIds(rows, PROBE_PARAM_IDS.fuel_level, ["fuel_level_1"]);
    const fuelRate    = getParamRawByIds(rows, PROBE_PARAM_IDS.fuel_rate, ["engine_fuel_rate"]);
    const oilPressure = getParamRawByIds(rows, PROBE_PARAM_IDS.oil_pressure, ["engine_oil_pressure"]);
    const oilTemp     = getParamRawByIds(rows, PROBE_PARAM_IDS.oil_temp, ["engine_oil_temperature_1"]);
    const coolantTemp = getParamRawByIds(rows, PROBE_PARAM_IDS.coolant_temp, ["engine_coolant_temperature"]);
    const fuelTemp    = getParamRawByIds(rows, PROBE_PARAM_IDS.fuel_temp, ["engine_fuel_temperature_1"]);
    const odometer    = getParamRawByIds(rows, PROBE_PARAM_IDS.odometer, ["sys_param_vehicle_distance"]);
    const windshield  = getParamRawByIds(rows, PROBE_PARAM_IDS.windshield, ["arm_analog_input_3"]);

    probeScreenEl.innerHTML = `
      <div class="probeRow">
        <div class="probeBox"><b>ignition</b><br>${ignitionLamp(header.ignition)}</div>
        <div class="probeBox"><b>communication</b><br>${esc(header.communication)}</div>
      </div>
      <div class="probeRow">
        <div class="probeBox"><b>progress</b><br>${esc(header.progress)}</div>
        <div class="probeBox"><b>driver code</b><br>${esc(header.driver_code)}</div>
      </div>
      <div class="probeRow">
        <div class="probeBox"><b>[license number]</b> ${esc(header.license_number)}</div>
        <div class="probeBox"><b>serial</b> ${esc(header.serial)}</div>
      </div>
      <div class="probeRow">
        <div class="probeBox"><b>client</b> ${esc(header.client)}</div>
        <div class="probeBox"><b>model</b> ${esc(header.model)}</div>
      </div>

      <div class="kv" style="margin:4px 0 8px">
        ${moduleChip("CAN0", comm.can0)}
        ${moduleChip("CAN1", comm.can1)}
        ${moduleChip("J1708", comm.j1708)}
        ${moduleChip("Dallas", comm.dallas)}
        ${moduleChip("Ramzor", comm.ramzor)}
      </div>

      <div class="probeBig">
        <div class="probeSectionTitle">FUEL</div>
        ${probeLine("engine_total_fuel_used", fuelTotal)}
        ${probeLine("fuel_level_1", fuelLvl)}
        ${probeLine("engine_fuel_rate", fuelRate)}

        <div class="probeSectionTitle">PRESSURE</div>
        ${probeLine("engine_oil_pressure", oilPressure)}

        <div class="probeSectionTitle">TEMPERATURE</div>
        ${probeLine("engine_oil_temperature_1", oilTemp)}
        ${probeLine("engine_coolant_temperature", coolantTemp)}
        ${probeLine("engine_fuel_temperature_1", fuelTemp)}

        <div class="probeSectionTitle">ODOMETER</div>
        ${probeLine("sys_param_vehicle_distance", odometer)}

        <div class="probeSectionTitle">WINDSHIELD</div>
        ${probeLine("arm_analog_input_3", windshield)}

        <div class="probeLegend">${esc(comm.detail)}</div>
      </div>
    `;
  }


  // PROBE_HELPERS_RESTORED_V1
  function esc(v){
    const s = (v == null) ? "—" : String(v);
    return s.replace(/[&<>"]/g, ch => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[ch]));
  }

  function rowParamId(p){
    return p?.id ?? p?.param_id ?? p?.parameter_id ?? p?.parameter?.id ?? p?.param?.id ?? p?.index ?? null;
  }

  function displayValue(p){
    const v = firstNonEmpty([p?.value, p?.val, p?.param_value, p?.parameter_value]);
    if (v !== "—") return String(v);
    const rv = firstNonEmpty([p?.raw_value, p?.rawValue, p?.raw, p?.parameter_raw_value]);
    if (rv !== "—") return String(rv);
    return "";
  }

  function extractRowsFromSnapshot(snap){
    const s = snap || {};
    const pickArr = (cands) => {
      for (const x of cands){
        if (Array.isArray(x)) return x;
        if (x && Array.isArray(x.rows)) return x.rows;
        if (x && Array.isArray(x.items)) return x.items;
        if (x && Array.isArray(x.data)) return x.data;
      }
      return [];
    };

    const params = pickArr([
      s.parameters, s.params,
      s?.data?.parameters, s?.data?.params,
      s?.snapshot?.parameters, s?.snapshot?.params,
      s?.payload?.parameters, s?.payload?.params
    ]);

    const ms = pickArr([
      s.moduleState, s.module_state, s.modules,
      s?.data?.moduleState, s?.data?.module_state, s?.data?.modules,
      s?.snapshot?.moduleState, s?.snapshot?.module_state, s?.snapshot?.modules,
      s?.payload?.moduleState, s?.payload?.module_state, s?.payload?.modules
    ]);

    return { params, ms };
  }

  function renderParamsTable(rows, filterText){
    if (!paramsBodyEl) return;
    const q = String(filterText || "").trim().toLowerCase();
    const list = Array.isArray(rows) ? rows : [];

    const filtered = !q ? list : list.filter(p => {
      const idTxt = normIdVariants(rowParamId(p)).join(" ");
      const hay = [
        p?.name, p?.type, p?.source, p?.last_update, p?.lastUpdate,
        p?.value, p?.raw_value, idTxt
      ].map(v => String(v ?? "").toLowerCase()).join(" | ");
      return hay.includes(q);
    });

    if (!filtered.length){
      paramsBodyEl.innerHTML = `<tr><td colspan="5" class="muted">sem parâmetros</td></tr>`;
      return;
    }

    paramsBodyEl.innerHTML = filtered.map(p => {
      const name = p?.name ?? "—";
      const type = p?.type ?? p?.param_type ?? "—";
      const idTxt = normIdVariants(rowParamId(p))[0] || "";
      const valueTxt = displayValue(p) || "—";
      const rawTxt = firstNonEmpty([p?.raw_value, p?.rawValue, p?.raw]);
      const shown = (rawTxt !== "—" && valueTxt !== rawTxt) ? `${valueTxt} / ${rawTxt}` : valueTxt;
      const last = firstNonEmpty([p?.last_update, p?.lastUpdate, p?.updated_at, p?.ts]);
      const source = firstNonEmpty([p?.source, p?.src]);
      const nameHtml = idTxt ? `${esc(name)} <span class="muted" style="font-size:11px">[#${esc(idTxt)}]</span>` : esc(name);

      return `<tr>
        <td>${nameHtml}</td>
        <td>${esc(type)}</td>
        <td>${esc(shown)}</td>
        <td>${esc(last)}</td>
        <td>${esc(source)}</td>
      </tr>`;
    }).join("");
  }

  function renderMsTable(msRows){
    if (!msBodyEl) return;
    const list = Array.isArray(msRows) ? msRows : [];

    if (!list.length){
      msBodyEl.innerHTML = `<tr><td colspan="6" class="muted">sem module state</td></tr>`;
      return;
    }

    msBodyEl.innerHTML = list.map(r => {
      const id = rowModuleId(r);
      const name = rowModuleName(r) || "—";
      const active = firstNonEmpty([r?.active]);
      const ok = firstNonEmpty([r?.ok]);
      const wasOk = firstNonEmpty([r?.was_ok, r?.wasOk]);
      const msg = firstNonEmpty([r?.message, r?.msg, r?.error]);

      return `<tr>
        <td>${esc(id == null ? "—" : id)}</td>
        <td>${esc(name)}</td>
        <td>${esc(active)}</td>
        <td>${esc(ok)}</td>
        <td>${esc(wasOk)}</td>
        <td>${esc(msg)}</td>
      </tr>`;
    }).join("");
  }

  function renderCanSnapshot(snap){
    const x = extractRowsFromSnapshot(snap);
    __LAST_CAN = x;

    const withValue = x.params.filter(p => displayValue(p).trim() !== "").length;

    pillParamsEl.textContent = `params: ${x.params.length}`;
    pillParamsWithEl.textContent = `com valor: ${withValue}`;
    pillMsEl.textContent = `module: ${x.ms.length}`;

    try { renderProbeScreen(LAST_INST, snap, x); } catch(_e) {
      console.error("[CAN_PROBE] renderProbeScreen error", _e);
      if (probeScreenEl) probeScreenEl.textContent = "erro ao renderizar probe (veja console)";
    }
    renderParamsTable(x.params, (canFilterEl && canFilterEl.value) ? canFilterEl.value : "");
    renderMsTable(x.ms);
  }

  if (canFilterEl){
    canFilterEl.addEventListener("input", () => {
      renderParamsTable(__LAST_CAN.params, canFilterEl.value);
    });
  }


  async function loadInstallation(id){
    setStatus("carregando...");
    const r = await api(`/api/installations/${encodeURIComponent(id)}`);
    if (r.status === 200 && r.data){
      const inst = r.data;
      LAST_INST = inst;
      const snap = extractCanSnapshot(inst);
      
      
          renderCanSnapshot(snap);
outEl.textContent = pretty({ installation: inst, can_snapshot: snap });
      qs("installation_id").value = instIdOf(inst) || id;
      localStorage.setItem("can_probe_last_installation_id", instIdOf(inst) || id);

      const st = (inst && inst.status) ? String(inst.status) : "ok";
      setStatus(st);
    } else {
      outEl.textContent = pretty(r);
      if (r.status === 404){
        // id antigo no localStorage costuma causar confusão
        try { localStorage.removeItem("can_probe_last_installation_id"); } catch(_){}
        setStatus("installation_id não encontrado (limpei o cache local)");
      } else {
        setStatus("erro ao carregar");
      }
    }
    return r;
  }

  async function createProbe(){
    const vehicleId = qs("vehicle_id").value.trim();
    if (!vehicleId) return setStatus("informe vehicle_id");
    setStatus("criando CAN_PROBE...");
    const payload = {
      service: "CAN_PROBE",
      vehicle_id: vehicleId,
      vehicleId: vehicleId,
      target_client_id: qs("target_client_id").value.trim() || null,
      vehicleSettingId: qs("vehicleSettingId").value.trim() || null,
      comments: qs("comments").value || null,
      installationDate: new Date().toISOString()
    };
    const r = await api("/api/installations", { method:"POST", json: payload });
    outEl.textContent = pretty(r);
    if (r.status === 201 && r.data){
      const id = instIdOf(r.data);
      if (id){
        qs("installation_id").value = id;
        setStatus("criado — carregando...");
        await loadInstallation(id);
      } else {
        setStatus("criado (sem id no retorno)");
      }
    } else {
      setStatus("erro ao criar");
    }
  }

  async function requestSnapshot(){
    const id = qs("installation_id").value.trim();
    if (!id) return setStatus("informe installation_id");

    // resolve vehicle_id: input -> last loaded installation -> payload
    let vehicle_id = Number(qs("vehicle_id").value.trim());
    if (!Number.isFinite(vehicle_id) || vehicle_id <= 0){
      const v = pick(LAST_INST, [
        ["resolved","vehicle_id"],
        ["payload","vehicle_id"],
        ["payload","vehicleId"],
        ["vehicle_id"],
        ["vehicleId"]
      ]);
      vehicle_id = (v != null) ? Number(v) : NaN;
    }
    if (!Number.isFinite(vehicle_id) || vehicle_id <= 0){
      return setStatus("informe vehicle_id (input ou payload/resolved)");
    }

    setStatus("request snapshot...");
    const r = await api(`/api/installations/${encodeURIComponent(id)}/actions/request-can-snapshot`, {
      method:"POST",
      json:{ vehicle_id, ...PROBE_SNAPSHOT_REQ }
    });

    // mostra resposta do POST (útil p/ headers/erros)
    outEl.textContent = pretty({ request: r });

    if (r.status >= 400){
      setStatus("erro no request snapshot");
      return;
    }

    // polling: esperar backend preencher can.summary/snapshots
    await pollCan(id, PROBE_POLL_OPTS);
  }

  async function pollCan(id, { tries=360, sleepMs=2000 } = {}){
    for (let i=0; i<tries; i++){
      const r = await api(`/api/installations/${encodeURIComponent(id)}`);
      if (r.status === 200 && r.data){
        const inst = r.data;
        LAST_INST = inst;
        const snap = extractCanSnapshot(inst);
        try { renderCanSnapshot(snap); } catch(_e) {}
        outEl.textContent = pretty({
          poll: { attempt: i+1, tries, inst_status: inst.status || null },
          inst: { installation_id: instIdOf(inst), status: inst.status || null, jobs: (inst.jobs||[]).slice(-3) },
          snap_counts: (snap && snap.counts) ? snap.counts : null
        });
const hasSummary = !!(snap && snap.summary);
        const hasList = !!(snap && Array.isArray(snap.snapshots) && snap.snapshots.length);
        const hasCounts = !!(snap && snap.counts && ((snap.counts.params_total||0)>0 || (snap.counts.module_total||0)>0));
        const hasParams = !!(snap && Array.isArray(snap.parameters) && snap.parameters.length);
        const hasModule = !!(snap && Array.isArray(snap.moduleState) && snap.moduleState.length);
        const statusReady = String(inst.status || "") === "CAN_SNAPSHOT_READY";

        const hdr = (typeof getHeaderLite === "function")
          ? getHeaderLite(inst, snap, (__LAST_CAN && __LAST_CAN.params) ? __LAST_CAN.params : [])
          : null;

        const headerReady = !!(hdr && [
          hdr.communication, hdr.progress, hdr.driver_code,
          hdr.license_number, hdr.serial, hdr.client, hdr.model
        ].some(v => {
          const s = String(v == null ? "" : v).trim();
          return !!s && s !== "—" && s !== "CAN sem sinal";
        }));

        if (statusReady || ((hasParams || hasModule || hasCounts || hasList || hasSummary) && headerReady)){
          const p = (snap && snap.counts && (snap.counts.params_total||snap.counts.paramsTotal)) || (snap && snap.parameters && snap.parameters.length) || 0;
          const m = (snap && snap.counts && (snap.counts.module_total||snap.counts.moduleTotal)) || (snap && snap.moduleState && snap.moduleState.length) || 0;
          setStatus(`CAN pronto ✅ (params=${p}, modules=${m})`);
          return r;
        }
      } else {
        outEl.textContent = pretty({ poll: { attempt: i+1, tries }, error: r });
      }

      setStatus(`aguardando CAN... (${i+1}/${tries})`);
      await new Promise(res => setTimeout(res, sleepMs));
    }
    setStatus("timeout aguardando CAN — use Carregar");
    return null;
  }

async function approveCan(){
    const id = qs("installation_id").value.trim();
    if (!id) return setStatus("informe installation_id");
    setStatus("aprovando CAN...");
    const r = await api(`/api/installations/${encodeURIComponent(id)}/actions/approve-can`, { method:"POST", json:{} });
    outEl.textContent = pretty(r);
    await loadInstallation(id);
  }

  qs("btnCreate").addEventListener("click", createProbe);
  qs("btnReq").addEventListener("click", requestSnapshot);
  qs("btnLoad").addEventListener("click", () => loadInstallation(qs("installation_id").value.trim()));
  qs("btnApprove").addEventListener("click", approveCan);

  const last = localStorage.getItem("can_probe_last_installation_id");
  if (last){
    qs("installation_id").value = last;
    loadInstallation(last).catch(()=>{});
  }
</script>
</body>
</html>
