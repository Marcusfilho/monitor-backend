"use strict";


const patchC8 = require('./patchC8_allowedGroups'); // PATCH_C8_ALLOWED_GROUPS
/* PATCH_C6_HTML5 v2026-02-02 (NO-BACKTICKS)
 * - SAVE_VHCL_ACTIVATION_NEW: garante FIELD_IDS=1,2,6 e FIELD_VALUE com campo 1 copiando 2 (fallback 6)
 * - USER_GROUPS/LOGIN_USER_GROUPS: cache client_id -> group_id
 * - ASSET_BASIC_SAVE: injeta GROUP_ID do cache (guardrail se não houver cache)
 */
(() => {
  if (globalThis.__PATCH_C6_HTML5) return;
  globalThis.__PATCH_C6_HTML5 = { version: 'C6', ts: new Date().toISOString() };

  const origFetch = globalThis.fetch;
  if (typeof origFetch !== 'function') {
    console.error('[PATCH_C6] global fetch missing; nothing patched');
    return;
  }

  const groupMap = new Map(); // clientId -> groupId

  function safeToStr(v){
    try { return (v === undefined || v === null) ? '' : String(v); } catch { return ''; }
  }

  function extractParams(init){
    const body = init && init.body;
    if (!body) return null;
    if (body instanceof URLSearchParams) return body;
    if (typeof body === 'string') {
      if (body.includes('=') && (body.includes('&') || body.startsWith('action=') || body.includes('action='))) {
        return new URLSearchParams(body);
      }
    }
    return null;
  }

  function setBodyFromParams(init, params){
    init = init || {};
    init.body = params.toString();
    init.headers = init.headers || {};
    try {
      if (init.headers instanceof Headers) {
        if (!init.headers.get('content-type')) init.headers.set('content-type', 'application/x-www-form-urlencoded; charset=utf-8');
      } else {
        const h = init.headers;
        const has = Object.keys(h).some(k => k.toLowerCase() === 'content-type');
        if (!has) h['content-type'] = 'application/x-www-form-urlencoded; charset=utf-8';
      }
    } catch {}
    return init;
  }

  function parseFieldValueMap(fieldValueStr){
    const map = new Map();
    const parts = safeToStr(fieldValueStr).split(',');
    for (const raw of parts) {
      const tok = raw.trim();
      if (!tok) continue;
      const i = tok.indexOf(':');
      if (i <= 0) continue;
      const k = tok.slice(0, i).trim();
      const v = tok.slice(i + 1); // keep as-is
      if (k) map.set(k, v);
    }
    return map;
  }

  function ensureField1(params){
    const idsStr = safeToStr(params.get('FIELD_IDS'));
    if (!idsStr) return { changed:false, reason:'no FIELD_IDS' };

    const ids = idsStr.split(',').map(s => s.trim()).filter(Boolean);
    const valMap = parseFieldValueMap(params.get('FIELD_VALUE'));

    // always guarantee 1,2,6 exist (and ordered)
    const v1 = (valMap.get('2') || valMap.get('6') || '');

    const rest = ids.filter(x => x !== '1' && x !== '2' && x !== '6');
    const ordered = ['1','2','6', ...rest];

    params.set('FIELD_IDS', ordered.join(','));

    if (!valMap.has('2')) valMap.set('2','');
    if (!valMap.has('6')) valMap.set('6','');
    valMap.set('1', v1);

    const parts = ordered.map(id => String(id) + ':' + (valMap.get(id) ?? ''));
    params.set('FIELD_VALUE', ',' + parts.join(','));

    // changed if 1 wasn't present OR ordering/values altered
    return { changed: !ids.includes('1'), v1Used: v1 };
  }

  function rememberGroupsFromText(text){
    const t = safeToStr(text);
    if (!t) return 0;

    let found = 0;
    let m;

    // XML-ish patterns
    const re = /CLIENT_ID\s*=\s*\"(\d+)\"[^>]*GROUP_ID\s*=\s*\"(\d+)\"/gi;
    while ((m = re.exec(t))) { groupMap.set(m[1], m[2]); found++; }

    const re2 = /GROUP_ID\s*=\s*\"(\d+)\"[^>]*CLIENT_ID\s*=\s*\"(\d+)\"/gi;
    while ((m = re2.exec(t))) { groupMap.set(m[2], m[1]); found++; }

    // JSON-ish fallback (very lightweight): client_id:123 ... group_id:456
    const re3 = /\"client_id\"\s*:\s*(\d+)[\s\S]{0,200}?\"group_id\"\s*:\s*(\d+)/gi;
    while ((m = re3.exec(t))) { groupMap.set(m[1], m[2]); found++; }

    return found;
  }

  function ensureGroupId(params){
    const clientId = safeToStr(params.get('CLIENT_ID')).trim();
    if (!clientId) return { changed:false, reason:'no CLIENT_ID' };

    const groupId = safeToStr(params.get('GROUP_ID')).trim();
    if (groupId) return { changed:false, reason:'already has GROUP_ID' };

    const resolved = groupMap.get(clientId);
    if (!resolved) return { changed:false, reason:'no groupMap for client ' + clientId };

    params.set('GROUP_ID', resolved);
    return { changed:true, groupId:resolved };
  }

  globalThis.fetch = async (url, init = {}) => {
    let params = null;
    try { params = extractParams(init); } catch {}
    const action = params ? safeToStr(params.get('action')) : '';

    // pre-request patch
    if (params && action === 'SAVE_VHCL_ACTIVATION_NEW') {
      const r = ensureField1(params);
      if (r && r.changed) init = setBodyFromParams(init, params);
    }

    if (params && action === 'ASSET_BASIC_SAVE') {
      const r = ensureGroupId(params);
      if (r && r.changed) init = setBodyFromParams(init, params);
      else if (r && r.reason && r.reason.indexOf('no groupMap') === 0) {
        throw new Error('[PATCH_C6] missing GROUP_ID: execute USER_GROUPS first for client_id=' + safeToStr(params.get('CLIENT_ID')));
      }
    }

    const res = await origFetch(url, init);
        

    // post-response cache
    try {
      if (params && (action === 'USER_GROUPS' || action === 'LOGIN_USER_GROUPS')) {
        const txt = await res.clone().text();
        const n = rememberGroupsFromText(txt);
        if (n) console.log('[PATCH_C6] cached groups: +' + n + ' entries (total=' + groupMap.size + ')');
      }
    } catch (e) {
      console.log('[PATCH_C6] cache parse error:', e && (e.message || e.toString()));
    }

    return res;
  };

  console.log('[PATCH_C6] installed (fetch hook active)');
})();

// === CAPTURE_FETCHWRAP_V8: capture ASSET_BASIC_LOAD via fetch clone ===
const __CAPTURES = {};

function __parseFirstTagAttributes(xml, tagName){
  const t = String(xml || "");
  const re = new RegExp(`<${tagName}\\b([^>]*)\\/?>`, "i");
  const m = re.exec(t);
  if (!m) return null;
  const attrsStr = m[1] || "";
  const attrs = {};
  const reAttr = /([A-Za-z0-9_:-]+)\s*=\s*"([^"]*)"/g;
  let a;
  while ((a = reAttr.exec(attrsStr))) attrs[a[1]] = a[2];
  return attrs;
}

function __snip(text, n){
  const t = String(text || "").replace(/\s+/g, " ").trim();
  return t.slice(0, (n || 900));
}

try {
  const __origFetch = globalThis.fetch;
  if (__origFetch && !__origFetch.__capV8Wrapped) {
    const wrapped = async function(url, init){
      const u = String(url || "");
      globalThis.__LAST_FETCH_URL = u; // PATCH_A11
      globalThis.__LAST_FETCH_URL = u;
      const body = init && init.body != null ? String(init.body) : "";
      const want = u.includes("AppEngine_2_1/default.aspx") && body.includes("action=ASSET_BASIC_LOAD");

      // chama o fetch anterior (que já inclui PATCH_C6)
      const res = await __origFetch(url, init);

      if (!want) return res;

      try {
        const txt = await res.clone().text();
        const attrs = __parseFirstTagAttributes(txt, "ASSET") || __parseFirstTagAttributes(txt, "VHCL") || null;

        __CAPTURES.ASSET_BASIC_LOAD = {
          ts: Date.now(),
          url: u,
          req: __snip(body, 1200),
          resp: __snip(txt, 1600),
          tag: attrs
        };

        console.log("[CAPTURE_FETCHWRAP_V8] captured ASSET_BASIC_LOAD bytes=" + String(txt || "").length);
      } catch (e) {
        console.log("[CAPTURE_FETCHWRAP_V8] capture error:", e && (e.message || e.toString()));
      }

      return res;
    };
    wrapped.__capV8Wrapped = true;
    globalThis.fetch = wrapped;
    __origFetch.__capV8Wrapped = true;
  }
} catch {}
// === /CAPTURE_FETCHWRAP_V8 ===

/**
 * v8 - HTML5 Actions (multi-step)
 * - mantém guardrails anti-job-preso (JOB_MAX_MS + COMPLETE sempre)
 * - login HTML5 via APPLICATION_LOGIN (TFL_SESSION)
 * - suporta executar uma lista de ações HTML5 por job (payload.html5Steps[])
 *   permitindo UNINSTALL / MAINT_WITH_SWAP / CHANGE_COMPANY sem hardcode de payload.
 * - INSTALL continua suportado via builder SAVE_VHCL_ACTIVATION_NEW (igual v7)
 */

const fs = require("fs");
const fsp = fs.promises;

const BASE = (process.env.JOB_SERVER_BASE_URL || "").replace(/\/+$/, "");
const WORKER_KEY = (process.env.WORKER_KEY || "").trim();
const WORKER_ID = (process.env.WORKER_ID || "tunel").trim();

const POLL_MS = Number(process.env.POLL_INTERVAL_MS || 3000);
const HTTP_TIMEOUT_MS = Number(process.env.HTTP_TIMEOUT_MS || 60000);
const JOB_MAX_MS = Number(process.env.JOB_MAX_MS || 60000);

const DRY_RUN = String(process.env.DRY_RUN || "1") !== "0";
const EXECUTE_HTML5 =
  String(process.env.EXECUTE_HTML5 || "0").toLowerCase() === "true" ||
  String(process.env.EXECUTE_HTML5 || "0") === "1";

const HTML5_ACTION_URL = (process.env.HTML5_ACTION_URL || "https://html5.traffilog.com/AppEngine_2_1/default.aspx").trim();
const COOKIEJAR_PATH = (process.env.HTML5_COOKIEJAR_PATH || "/tmp/html5_cookiejar.json").trim();

const HTML5_LOGIN_NAME = (process.env.HTML5_LOGIN_NAME || "").trim();
const HTML5_PASSWORD = (process.env.HTML5_PASSWORD || "").trim();
const HTML5_LANGUAGE = String(process.env.HTML5_LANGUAGE || "7001").trim();
const HTML5_ORIG_ZOOM_ID = String(process.env.HTML5_ORIG_ZOOM_ID || "3472").trim();

if (!BASE) { console.error("[html5_v8] missing JOB_SERVER_BASE_URL"); process.exit(2); }
if (!WORKER_KEY) { console.error("[html5_v8] missing WORKER_KEY"); process.exit(2); }

function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }
function nowISO(){ return new Date().toISOString(); }
function safeSnippet(text, n=260){
  const t = String(text || "").replace(/\s+/g, " ").trim();
  return t.slice(0, n);
}
function cookieKeysFromCookieHeader(cookieHeader){
  const c = String(cookieHeader || "");
  const keys = [];
  for (const part of c.split(";")) {
    const p = part.trim();
    if (!p) continue;
    const eq = p.indexOf("=");
    if (eq <= 0) continue;
    keys.push(p.slice(0, eq).trim());
  }
  return Array.from(new Set(keys));
}
function ensureCookieDefaults(cookieHeader){
  let c = String(cookieHeader || "").trim();
  const keys = new Set(cookieKeysFromCookieHeader(c));
  const add = (k, v) => {
    if (!keys.has(k)) {
      c = c ? (c + "; " + k + "=" + v) : (k + "=" + v);
      keys.add(k);
    }
  };
  add("EULA_APPROVED", "1");
  add("LOGIN_DATA", "");
  add("APPLICATION_ROOT_NODE", '{"node":"-2"}'); // igual ao browser
  return c;
}

async function loadCookieJar(){
  try {
    const raw = await fsp.readFile(COOKIEJAR_PATH, "utf-8");
    const j = JSON.parse(raw);
    return { cookie: String(j.cookie || ""), updatedAt: j.updatedAt || null };
  } catch { return { cookie: "", updatedAt: null }; }
}
async function saveCookieJar(cookieHeader, meta){
  const cookie = ensureCookieDefaults(cookieHeader || "");
  const keys = cookieKeysFromCookieHeader(cookie);
  const payload = { cookie, keys, updatedAt: nowISO(), meta: meta || {} };
  await fsp.writeFile(COOKIEJAR_PATH, JSON.stringify(payload, null, 2), { encoding:"utf-8", mode:0o600 });
  return keys;
}
function extractSetCookies(headers){
  if (headers && typeof headers.getSetCookie === "function") {
    try { return headers.getSetCookie() || []; } catch {}
  }
  const one = headers && typeof headers.get === "function" ? headers.get("set-cookie") : null;
  return one ? [one] : [];
}
function mergeCookies(existingCookieHeader, setCookieArr){
  const map = new Map();
  for (const part of String(existingCookieHeader || "").split(";")) {
    const p = part.trim(); if (!p) continue;
    const eq = p.indexOf("="); if (eq <= 0) continue;
    map.set(p.slice(0,eq).trim(), p.slice(eq+1).trim());
  }
  for (const sc of (setCookieArr || [])) {
    const first = String(sc || "").split(";")[0].trim();
    const eq = first.indexOf("="); if (eq <= 0) continue;
    map.set(first.slice(0,eq).trim(), first.slice(eq+1).trim());
  }
  const out=[]; for (const [k,v] of map.entries()) out.push(`${k}=${v}`);
  return out.join("; ");
}

async function fetchWithCookies(url, { method="GET", headers={}, body=null } = {}, cookieHeader=""){
  const controller = new AbortController();
  const t = setTimeout(() => controller.abort(), HTTP_TIMEOUT_MS);
  let cookie = ensureCookieDefaults(cookieHeader || "");
  try{
    const res = await fetch(url, {
      method,
      headers: { ...headers, ...(cookie?{cookie}:{}), "user-agent":"monitor-backend-html5-worker/8" },
      body,
      redirect:"manual",
      signal: controller.signal
    });
    cookie = mergeCookies(cookie, extractSetCookies(res.headers));
    const text = await res.text().catch(() => "");
    return { status: res.status, text, cookie, headers: res.headers };
  } finally { clearTimeout(t); }
}

// Job server
async function httpFetch(path, { method="GET", params=null, json=null } = {}) {
  const u = new URL(BASE + path);
  if (params) for (const [k,v] of Object.entries(params)) u.searchParams.set(k, String(v));
  const controller = new AbortController();
  const t = setTimeout(() => controller.abort(), HTTP_TIMEOUT_MS);
  try {
    const res = await fetch(u.toString(), {
      method,
      headers: { "x-worker-key": WORKER_KEY, ...(json ? { "content-type":"application/json" } : {}) },
      body: json ? JSON.stringify(json) : undefined,
      signal: controller.signal
    });
    const text = await res.text().catch(() => "");
    let data=null; try { data = text ? JSON.parse(text) : null; } catch { data=text; }
    return { status: res.status, data };
  } finally { clearTimeout(t); }
}
async function completeJob(id, status, result){
  // === CAPTURE_FETCHWRAP_V8_ATTACH ===
  try { if (result && typeof result === "object") result.captures = __CAPTURES; } catch {}
  // === /CAPTURE_FETCHWRAP_V8_ATTACH ===

  return httpFetch(`/api/jobs/${encodeURIComponent(String(id))}/complete`, { method:"POST", json:{ status, result, workerId: WORKER_ID } });
}
async function completeJobLogged(id, status, result){
  const r = await completeJob(id, status, result);
  console.log(`[html5_v8] COMPLETE_API id=${id} status=${status} http=${r.status}`);
  return r;
}

function withTimeout(promise, ms, label){
  let to;
  const t = new Promise((_, rej) => {
    to = setTimeout(() => rej(new Error(`timeout:${label}:${ms}ms`)), ms);
  });
  return Promise.race([promise.finally(() => clearTimeout(to)), t]);
}

// HTML5 login (APPLICATION_LOGIN)
async function html5BootstrapCookies(existingCookie){
  const r = await fetchWithCookies("https://html5.traffilog.com/appv2/index.htm", {
    method:"GET",
    headers:{ "accept":"text/html,application/xhtml+xml", "referer":"https://html5.traffilog.com/appv2/index.htm" }
  }, existingCookie || "");
  await saveCookieJar(r.cookie, { source:"bootstrap", httpStatus:r.status });
  return r.cookie;
}
async function html5LoginAndStoreCookies(existingCookie){
  if (!HTML5_LOGIN_NAME || !HTML5_PASSWORD) throw new Error("missing HTML5_LOGIN_NAME / HTML5_PASSWORD");

  let cookie = await html5BootstrapCookies(existingCookie || "");

  const body = new URLSearchParams({
    username: HTML5_LOGIN_NAME,
    password: HTML5_PASSWORD,
    language: HTML5_LANGUAGE,
    BOL_SAVE_COOKIE: "0",
    action: "APPLICATION_LOGIN",
    VERSION_ID: "2",
  }).toString();

  const r = await fetchWithCookies(HTML5_ACTION_URL, {
    method:"POST",
    headers:{
      "accept":"*/*",
      "content-type":"application/x-www-form-urlencoded",
      "origin":"https://html5.traffilog.com",
      "referer":"https://html5.traffilog.com/appv2/index.htm",
      "pragma":"no-cache",
      "cache-control":"no-cache"
    },
    body
  }, cookie);

  const keys = await saveCookieJar(r.cookie, { source:"login", httpStatus:r.status });
  const hasTfl = keys.includes("TFL_SESSION");
  return { status:r.status, cookie:r.cookie, cookieKeys:keys, snippet:safeSnippet(r.text), hasTfl };
}

function parseHtml5Message(text, actionName){
  // === PATCH_LOGOFF_REDIRECT_V8 ===
  // Alguns retornos vêm como <REDIRECT ...><ACTION>LOGOFF</ACTION></REDIRECT>
  // (sem <MESSAGE>). Tratar isso como login negado para forçar relogin + retry.
  const __t0 = String(text || "");
  const __redir = /<REDIRECT\b[^>]*>/i.exec(__t0);
  if (__redir) {
    const __tag = __redir[0] || "";
    const __isLogoff = /<ACTION>\s*LOGOFF\s*<\/ACTION>/i.test(__t0) || /\blogin\s*=\s*["']?-1["']?/i.test(__tag) || /index\.aspx\?node=-1/i.test(__t0);
    if (__isLogoff) {
      return { hasMessage:false, login:-1, isLoginNeg:true, status:"logoff", isErrorStatus:false, isRedirectLogoff:true };
    }
  }
  // === /PATCH_LOGOFF_REDIRECT_V8 ===

  const t = String(text || "");
  const m = /<MESSAGE\b[^>]*>/i.exec(t);
  if (!m) return { hasMessage:false };

  const tag = m[0];

  const loginM = /\blogin\s*=\s*["']?(-?\d+)["']?/i.exec(tag);
  const login = loginM ? Number(loginM[1]) : null;
  const isLoginNeg = (login !== null && login < 0) || /login\s*=\s*["']?-1["']?/i.test(tag);

  const statusM = /\bstatus\s*=\s*["']?([a-z0-9_-]+)["']?/i.exec(tag);
  const status = statusM ? String(statusM[1]).toLowerCase() : null;
  const isErrorStatus = status ? ["error","fail","failed","false","ko"].includes(status) : false;

  // fallback leve (não usar pra “inventar” — só pra sinalizar erro óbvio)
  const looksLikeErrorText = /\berror\b/i.test(t) && /\baction\b/i.test(t);

  return { hasMessage:true, login, isLoginNeg, status, isErrorStatus: (isErrorStatus || looksLikeErrorText) };
}


// === PATCH_CF1_V8 ===
function ensureCustomField1(fields){
  try{
    if (!fields || typeof fields !== "object") return;

    const idsStr = String(fields.FIELD_IDS ?? "").trim();
    const valStr = String(fields.FIELD_VALUE ?? "").trim();
    if (!idsStr) return;

    const ids = idsStr.split(",").map(x=>x.trim()).filter(Boolean);
    if (ids.includes("1")) return;

    // só aplica se for o caso clássico (tem 2 e/ou 6)
    if (!ids.includes("2") && !ids.includes("6")) return;

    const leadingComma = valStr.startsWith(",");
    const tokens = valStr.split(",").filter(Boolean);

    const map = {};
    for (const t of tokens){
      const i = t.indexOf(":");
      if (i <= 0) continue;
      const k = t.slice(0,i).trim();
      const v = t.slice(i+1);
      if (!k) continue;
      map[k] = v;
    }

    const baseVal = (map["2"] !== undefined) ? map["2"] : ((map["6"] !== undefined) ? map["6"] : "");
    map["1"] = baseVal;

    const newIds = ["1", ...ids];
    const outTokens = newIds.map(k => `${k}:${map[k] !== undefined ? map[k] : ""}`);

    fields.FIELD_IDS = newIds.join(",");
    fields.FIELD_VALUE = (leadingComma ? "," : "") + outTokens.join(",");
  } catch (e) {
    console.log("[html5_v8] warn ensureCustomField1:", e && (e.message || e.toString()));
  }
}
// === /PATCH_CF1_V8 ===


function ensureCustomField1_(fields, payload){
  try{
    const idsStr = String(fields.FIELD_IDS || "").trim();
    const valStr = String(fields.FIELD_VALUE || "").trim();

    const ids = idsStr.split(",").map(s=>s.trim()).filter(Boolean);
    if (ids.includes("1")) return;

    // parse ",2:aaa,6:bbb" -> map
    const map = new Map();
    const raw = valStr.replace(/^,/, "");
    const parts = raw ? raw.split(",").map(s=>s.trim()).filter(Boolean) : [];
    for (const p of parts){
      const i = p.indexOf(":");
      if (i > 0){
        const k = p.slice(0,i).trim();
        const v = p.slice(i+1);
        if (k) map.set(k, v);
      }
    }

    let v1 = "";
    if (payload && typeof payload === "object") {
      v1 = String(payload.customField1Value || payload.custom_field_1 || payload.customField1 || "").trim();
    }
    if (!v1) v1 = (map.get("2") || map.get("6") || "");

    // força 1 na frente
    ids.unshift("1");
    const uniq = [];
    const seen = new Set();
    for (const x of ids){
      if (!seen.has(x)) { seen.add(x); uniq.push(x); }
    }
    fields.FIELD_IDS = uniq.join(",");

    map.set("1", v1);

    // rebuild FIELD_VALUE seguindo a ordem dos ids
    const out = [];
    for (const code of uniq){
      if (map.has(code)) out.push(code + ":" + map.get(code));
    }
    if (out.length) fields.FIELD_VALUE = "," + out.join(",");
  }catch(e){}
}

function buildSaveActivationFields(payload){
  const serial = String(payload.serial || payload.DIAL_NUMBER || payload.INNER_ID || "").trim();
  const plate  = String(payload.plate || payload.LICENSE_NMBR || "").trim();
  const installationDate = String(payload.installationDate || payload.INSTALLATION_DATE || "").trim();
  const assetType = payload.assetType != null ? String(payload.assetType) : "";

  const fields = {
    ASSIGNED_VEHICLE_SETTING_ID: String(payload.ASSIGNED_VEHICLE_SETTING_ID ?? -1),
    LINK_AND_RUN: String(payload.LINK_AND_RUN ?? 0),
    UPDATE_DRIVER_CODE: String(payload.UPDATE_DRIVER_CODE ?? 0),
    LOG_UNIT_DATA_UNTIL_DATE: String(payload.LOG_UNIT_DATA_UNTIL_DATE || installationDate),

    VEHICLE_ID: payload.vehicleId != null ? String(payload.vehicleId) : "",
    FIELD_IDS: String(payload.fieldIds || payload.FIELD_IDS || ""),
    FIELD_VALUE: String(payload.fieldValue || payload.FIELD_VALUE || ""),

    LICENSE_NMBR: plate,
    INNER_ID: String(payload.INNER_ID || serial),

    SAFETY_GROUP_ID: String(payload.SAFETY_GROUP_ID ?? -1),
    NICK_NAME: String(payload.NICK_NAME ?? ""),

    DIAL_NUMBER: serial,
    SIM_NUMBER: String(payload.SIM_NUMBER ?? ""),

    UNIT_TYPE_ID: String(payload.UNIT_TYPE_ID ?? 1),
    MILAGE_SOURCE_ID: String(payload.MILAGE_SOURCE_ID ?? 5067),

    ID_DRIVER_ID: String(payload.ID_DRIVER_ID ?? -1),
    ID_TEMP_SENSORS: String(payload.ID_TEMP_SENSORS ?? -1),
    ID_D_MASS: String(payload.ID_D_MASS ?? -1),
    ID_TRAILER: String(payload.ID_TRAILER ?? -1),
    ID_DOORS: String(payload.ID_DOORS ?? -1),
    ID_MDT: String(payload.ID_MDT ?? -1),
    ID_MODEM: String(payload.ID_MODEM ?? -1),
    ID_TACHOGRAPH: String(payload.ID_TACHOGRAPH ?? -1),

    ACCOSSORIES_COMMENTS: String(payload.ACCOSSORIES_COMMENTS ?? ""),

    INSTALLATION_DATE: installationDate,
    INSTALLED_BY: String(payload.installedBy || payload.INSTALLED_BY || ""),
    INSTALLATION_PLACE: String(payload.installationPlace || payload.INSTALLATION_PLACE || ""),

    WARRANTY_START_DATE: String(payload.WARRANTY_START_DATE || payload.warrantyStartDate || installationDate),
    WARRANTY_PERIOD_ID: String(payload.WARRANTY_PERIOD_ID ?? 1),

    ASSET_TYPE: assetType,
    LOGISTIC_COMMENTS: String(payload.LOGISTIC_COMMENTS ?? ""),

    FIRMWARE_TYPE_ID: String(payload.FIRMWARE_TYPE_ID ?? 2),
    iDRIVE_UNIT_SN: String(payload.iDRIVE_UNIT_SN ?? ""),

    DUPLICATE: String(payload.DUPLICATE ?? 0),
    DUPLICATE_VEHICLE: String(payload.DUPLICATE_VEHICLE ?? -1),

    SVR_ID: String(payload.SVR_ID ?? -1),
    BUILD_ID: String(payload.BUILD_ID ?? ""),

    DUPLICATE_CLIENT: String(payload.DUPLICATE_CLIENT ?? -1),

    ORIG_ZOOM_ID: String(payload.ORIG_ZOOM_ID ?? HTML5_ORIG_ZOOM_ID),
    DUPLICATE_ZOOM_ID: String(payload.DUPLICATE_ZOOM_ID ?? ""),

    ORIG_ZOOM_NUMBER: String(payload.ORIG_ZOOM_NUMBER ?? ""),
    ORIG_ZOOM_DESCR: String(payload.ORIG_ZOOM_DESCR ?? ""),

    DUPLICATE_ZOOM_NUMBER: String(payload.DUPLICATE_ZOOM_NUMBER ?? ""),
    DUPLICATE_ZOOM_DESCR: String(payload.DUPLICATE_ZOOM_DESCR ?? ""),

    CLIENT_ID: payload.clientId != null ? String(payload.clientId) : "",

    action: "SAVE_VHCL_ACTIVATION_NEW",
    VERSION_ID: "2"
  };

  const extra = payload.html5ExtraFields || payload.extraFields || null;
  if (extra && typeof extra === "object") {
    for (const [k, v] of Object.entries(extra)) {
      if (v === undefined) continue;
      fields[String(k)] = String(v ?? "");
    }
  }
  ensureCustomField1(fields);
  ensureCustomField1_(fields, payload);
  return fields;
}

function encodeForm(fields){
  const usp = new URLSearchParams();
  for (const [k,v] of Object.entries(fields)) usp.set(k, String(v ?? ""));
  return usp.toString();
}

function normalizeStep(step, jobPayload){
  const s = step && typeof step === "object" ? step : {};
  const label = String(s.label || s.name || s.action || "step").slice(0, 40);
  const action = String(s.action || "").trim();

  // Se pedirem builder (para SAVE_VHCL_ACTIVATION_NEW), gera fields a partir do payload.
  if (s.useBuilder) {
    const src = (s.payload && typeof s.payload === "object") ? s.payload : jobPayload;
    const built = buildSaveActivationFields(src || {});
    return { label, action: built.action, fields: built, _from: "builder" };
  }

  const fields = (s.fields && typeof s.fields === "object") ? { ...s.fields } : null;
  if (!action && fields && fields.action) {
    return { label, action: String(fields.action), fields, _from: "fields.action" };
  }
  // PATCH_C8_ALLOWED_GROUPS_HOOK
  try {
    if (typeof patchC8 !== "undefined" && patchC8 && typeof patchC8.applyPatchC8AllowedGroups === "function") {
      const _job = (typeof job !== "undefined") ? job : ((typeof ctx !== "undefined" && ctx && ctx.job) ? ctx.job : null);
      const _cap = (typeof captures !== "undefined") ? captures : ((typeof ctx !== "undefined" && ctx && ctx.captures) ? ctx.captures : null);
      if (_job && _cap && typeof step !== "undefined") patchC8.applyPatchC8AllowedGroups(step, { job: _job, captures: _cap });
    }
  } catch (e) { /* ignore */ }
  if (!action) throw new Error(`html5Steps step missing action (label=${label})`);
  if (!fields) throw new Error(`html5Steps step missing fields for action=${action} (label=${label})`);
  return { label, action, fields, _from: "fields" };
}

async function html5CallFormAction(actionName, fields, cookieHeader){
  const f = { ...(fields || {}) };
  f.action = String(f.action || actionName);
  if (f.VERSION_ID === undefined) f.VERSION_ID = "2";
  if (String(f.action) === "SAVE_VHCL_ACTIVATION_NEW") ensureCustomField1(f);

  const body = encodeForm(f);
  const cookieFixed = ensureCookieDefaults(cookieHeader || "");

  const r = await fetchWithCookies(HTML5_ACTION_URL, {
    method:"POST",
    headers:{
      "content-type":"application/x-www-form-urlencoded; charset=UTF-8",
      "origin":"https://html5.traffilog.com",
      "referer":"https://html5.traffilog.com/appv2/index.htm"
    },
    body
  }, cookieFixed);

  const parsed = parseHtml5Message(r.text);
  await saveCookieJar(r.cookie, { source:`action:${actionName}`, httpStatus:r.status });

  return { httpStatus:r.status, snippet:safeSnippet(r.text), parsed };
}

async function html5RunStep(jobId, step, cookie){
  console.log(`[html5_v8] STAGE id=${jobId} step=${step.label} action=${step.action} attempt=1`);
  const r1 = await html5CallFormAction(step.action, step.fields, cookie);

  if (r1.parsed && r1.parsed.isLoginNeg) {
    console.log(`[html5_v8] STAGE id=${jobId} step=login`);
    const loginRes = await html5LoginAndStoreCookies(cookie);
    console.log(`[html5_v8] STAGE id=${jobId} step=login_done hasTfl=${loginRes.hasTfl} keys=${(loginRes.cookieKeys||[]).join(",")}`);

    console.log(`[html5_v8] STAGE id=${jobId} step=${step.label} action=${step.action} attempt=2`);
    const r2 = await html5CallFormAction(step.action, step.fields, loginRes.cookie);

    return { attempt:2, first:r1, login:loginRes, final:r2 };
  }

  return { attempt:1, first:r1, login:null, final:r1 };
}

function stepOk(stepRun){
  const f = stepRun && stepRun.final ? stepRun.final : null;
  if (!f) return false;
  if (f.httpStatus && Number(f.httpStatus) >= 400) return false;
  if (f.parsed && f.parsed.isLoginNeg) return false;
  if (f.parsed && f.parsed.isErrorStatus) return false;
  // heurística leve: alguns responses não têm <MESSAGE>
  return true;
}

function normService(v){
  const s = String(v || "").trim().toUpperCase();
  if (s === "DESINSTALACAO" || s === "DESINSTALAÇÃO") return "UNINSTALL";
  if (s === "MANUTENCAO_COM_TROCA" || s === "MANUTENÇÃO_COM_TROCA") return "MAINT_WITH_SWAP";
  if (s === "MANUTENCAO_SEM_TROCA" || s === "MANUTENÇÃO_SEM_TROCA") return "MAINT_NO_SWAP";
  if (s === "TROCA_EMPRESA" || s === "TROCA_DE_EMPRESA") return "CHANGE_COMPANY";
  return s;
}

function buildStepsForService(service, payload){
  // Prioridade: payload.html5Steps (lista explícita, com payload idêntico ao da UI)
  if (Array.isArray(payload.html5Steps) && payload.html5Steps.length) {
    return payload.html5Steps.map(s => normalizeStep(s, payload));
  }

  // Compat: payload.html5Action + payload.html5Fields (1 passo)
  if (payload.html5Action && payload.html5Fields) {
    return [normalizeStep({ label: "custom", action: payload.html5Action, fields: payload.html5Fields }, payload)];
  }

  // Fallback: INSTALL conhecido (builder)
  if (service === "INSTALL") {
    return [normalizeStep({ label: "install", useBuilder: true }, payload)];
  }

  // === PATCH_D1_HTML5_ACTIONS (v2026-02-03) ===
  const must = (cond, msg) => { if (!cond) throw new Error(msg); };

  const vId = payload.vehicle_id || payload.vehicleId || payload.VEHICLE_ID || payload.vehicleID || payload.VehicleId;
  const license = payload.license || payload.LICENSE || payload.license_nmbr || payload.license_nmbr_real || payload.LICENSE_NMBR;
  const serial = payload.serial || payload.SERIAL || payload.inner_id || payload.INNER_ID;

  const installerName = payload.installer_name || payload.installerName || payload.INSTALLER_NAME || "Installer";
  const comments = payload.comments || payload.COMMENTS || payload.comment || payload.note || payload.notes || "";

  const reasonCode = payload.reason_code || payload.REASON_CODE || "5501";
  const deliverCode = payload.deliver_code || payload.DELIVER_CODE || "5511";

  if (service === "UNINSTALL") {
    must(vId, "missing_vehicle_id_for_uninstall");
    return [
      normalizeStep({
        label: "uninstall_deactivate",
        action: "DEACTIVATE_VEHICLE_HIST",
        fields: {
          INSTALLER_NAME: String(installerName),
          REASON_CODE: String(reasonCode),
          DELIVER_CODE: String(deliverCode),
          COMMENTS: String(comments),
          VEHICLE_ID: String(vId),
          action: "DEACTIVATE_VEHICLE_HIST",
          VERSION_ID: "2"
        }
      }, payload)
    ];
  }

  if (service === "MAINT_NO_SWAP") {
    return [];
  }

  if (service === "MAINT_WITH_SWAP") {
    must(vId, "missing_vehicle_id_for_maint_with_swap");
    must(serial, "missing_serial_for_maint_with_swap");

    payload.VEHICLE_ID = String(vId);
    payload.INNER_ID = String(serial);
    if (license && !payload.LICENSE_NMBR) payload.LICENSE_NMBR = String(license);

    return [
      normalizeStep({
        label: "swap_deactivate",
        action: "DEACTIVATE_VEHICLE_HIST",
        fields: {
          INSTALLER_NAME: String(installerName),
          REASON_CODE: String(reasonCode),
          DELIVER_CODE: String(deliverCode),
          COMMENTS: String(comments),
          VEHICLE_ID: String(vId),
          action: "DEACTIVATE_VEHICLE_HIST",
          VERSION_ID: "2"
        }
      }, payload),
      normalizeStep({ label: "swap_activate", useBuilder: true }, payload)
    ];
  }

  if (service === "CHANGE_COMPANY") {
    const clientIdTarget = payload.client_id_target || payload.clientIdTarget || payload.CLIENT_ID_TARGET || payload.CLIENT_ID;
    const groupIdTarget  = payload.group_id_target  || payload.groupIdTarget  || payload.GROUP_ID_TARGET  || payload.GROUP_ID;

    must(vId, "missing_vehicle_id_for_change_company");
    must(clientIdTarget, "missing_client_id_target_for_change_company");
    must(groupIdTarget, "missing_group_id_target_for_change_company");

    return [
      normalizeStep({
        label: "change_company_save",
        action: "ASSET_BASIC_SAVE",
        fields: {
          ASSET_ID: String(vId),
          VEHICLE_ID: String(vId),
          CLIENT_ID: String(clientIdTarget),
          GROUP_ID: String(groupIdTarget),
          action: "ASSET_BASIC_SAVE",
          VERSION_ID: "2"
        }
      }, payload)
    ];
  }

  // Para outras ações: não inventar payload
  return [];
}

async function main(){
  console.log(`[html5_v8] started base=${BASE} worker=${WORKER_ID} poll=${POLL_MS}ms httpTimeout=${HTTP_TIMEOUT_MS} jobMax=${JOB_MAX_MS} dryRun=${DRY_RUN} exec=${EXECUTE_HTML5} cookiejar=${COOKIEJAR_PATH}`);

  while(true){
    try{
      const r = await httpFetch("/api/jobs/next", { params:{ type:"html5_install", worker:WORKER_ID } });
      if (r.status === 204) { await sleep(POLL_MS); continue; }
      if (r.status !== 200 || !r.data) { await sleep(POLL_MS); continue; }

      const job = r.data.job || r.data;
      const id = job.id || job.jobId || job._id;
      const payload = job.payload || {};
      const service = normService(payload.service);
      const hasSteps = Array.isArray(payload.html5Steps) && payload.html5Steps.length > 0;

      console.log(`[html5_v8] GOT job id=${id} service=${service || "?"}`);

      // === CAPTURE_FETCHWRAP_V8_RESET ===
      try { for (const k of Object.keys(__CAPTURES)) delete __CAPTURES[k]; } catch {}
      // === /CAPTURE_FETCHWRAP_V8_RESET ===
      let done = false;
      const finish = async (status, result) => {
        if (done) return;
        done = true;
        await completeJobLogged(id, status, result);
      };

      const jobRunner = async () => {
        const steps = buildStepsForService(service, payload);

        // DEBUG: não chama HTML5, só monta o payload do SAVE_VHCL_ACTIVATION_NEW
        if (service === "DEBUG_BUILD_SAVE_ACTIVATION_FIELDS") {
          const built = buildSaveActivationFields(payload || {});
          await finish("ok", {
            ok: true,
            service,
            note: "build-only (no HTML5 call)",
            built: {
              FIELD_IDS: built.FIELD_IDS,
              FIELD_VALUE: built.FIELD_VALUE,
              LICENSE_NMBR: built.LICENSE_NMBR,
              DIAL_NUMBER: built.DIAL_NUMBER,
              INNER_ID: built.INNER_ID
            }
          });
          return;
        }

        // serviços que deliberadamente NÃO mutam HTML5
        const html5ShouldSkip = (service === "MAINT_NO_SWAP" && steps.length === 0);

        if (DRY_RUN || !EXECUTE_HTML5) {
          await finish("ok", {
            ok:true,
            dryRun: DRY_RUN,
            exec: EXECUTE_HTML5,
            service,
            note: "DRY_RUN or EXECUTE_HTML5 off",
            plannedSteps: steps.map(s => ({ label:s.label, action:s.action, from:s._from }))
          });
          return;
        }

        if (html5ShouldSkip) {
          await finish("ok", {
            ok:true,
            service,
            note: "no HTML5 mutation by design for this service",
            cookieKeys: cookieKeysFromCookieHeader((await loadCookieJar()).cookie || "")
          });
          return;
        }

        if (!steps.length) {
          await finish("error", {
            ok:false,
            service,
            error:"missing_html5_payload",
            message:"For this service, provide payload.html5Steps[] (exact UI fields) or payload.html5Action/html5Fields. INSTALL is the only allowed fallback builder.",
          });
          return;
        }

        const jar = await loadCookieJar();
        let cookie = jar.cookie || "";

        const results = [];
        for (const s of steps) {
          const out = await html5RunStep(id, s, cookie);
          results.push({
            label: s.label,
            action: s.action,
            attempt: out.attempt,
            httpStatus: out.final ? out.final.httpStatus : null,
            ok: stepOk(out),
            snippet: out.final ? out.final.snippet : null,
            parsed: out.final ? out.final.parsed : null,
          });

          // atualiza cookie local para o próximo step
          cookie = (await loadCookieJar()).cookie || cookie;

          if (!stepOk(out)) {
            const msg = out && out.final && out.final.parsed && out.final.parsed.isLoginNeg
              ? "auth_failed_after_retry"
              : "step_failed";
            throw new Error(`${msg}:${s.label}:${s.action}`);
          }
        }

        const cookieKeys = cookieKeysFromCookieHeader((await loadCookieJar()).cookie || "");

        await finish("ok", {
          ok:true,
          service,
          cookieKeys,
          steps: results
        });
      };

      try{
        await withTimeout(jobRunner(), JOB_MAX_MS, `job:${id}`);
      } catch (e){
        const msg = e && (e.message || e.toString());
        console.log(`[html5_v8] JOB_FAIL id=${id} err=${msg}`);
        await finish("error", { ok:false, service, error:"job_exception_or_timeout", message: msg });
      }

    } catch (e) {
      // __ABORT_SOFTEN_A10__
      if (e && (e.name === "AbortError" || String((e && (e.message || e)) || "").toLowerCase().includes("aborted"))) {
        const lu = globalThis.__LAST_FETCH_URL ? String(globalThis.__LAST_FETCH_URL) : "";
        console.log("[html5_v8] warn: AbortError (timeout) url=" + lu);
        try { await sleep(1000); } catch (_) {}
        continue;
      }
      // PATCH_A11: soften AbortError
      if (e && (e.name === 'AbortError' || /aborted/i.test(String(e.message || e)))) {
        const lu = globalThis.__LAST_FETCH_URL ? String(globalThis.__LAST_FETCH_URL) : '';
        console.log('[html5_v8] warn: AbortError (timeout) url=' + lu);
      } else {
      console.log("[html5_v8] loop error:", e && (e.stack || e.message || e.toString()));
      }
      await sleep(POLL_MS);
    }
  }
}

main().catch(err => { console.error("[html5_v8] fatal:", err && (err.stack || err.message || err)); process.exit(1); });
